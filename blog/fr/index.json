[{"content":"","date":null,"permalink":"/blog/fr/","section":"Blog de Kelvas","summary":"","title":"Blog de Kelvas"},{"content":"","date":null,"permalink":"/blog/fr/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Que l’on soit seul ou en entreprise, dupliquer du code n’est jamais une bonne pratique. C’est l’une des premières règles en informatique : lorsqu’on crée quelque chose, on le réutilise, on le consolide, mais on évite de le recréer, sauf exception.\nNotre objectif ici sera donc de créer des bibliothèques réutilisables et facilement intégrables dans n’importe quel projet ou autre bibliothèque.\nNous n’aborderons pas ici la question de l’obfuscation de code. Chaque package NuGet que nous créerons, contenant les DLL, sera potentiellement lisible par quiconque. Nous traiterons de l’obfuscation du code dans un autre article.\nPour simplifier, nous allons voir comment créer une bibliothèque NuGet à partir de code C# et la publier sur GitHub.\nCela vous permettra d’intégrer vos bibliothèques très facilement à l’aide de NuGet, comme vous le faites déjà pour n’importe quelle bibliothèque open source utilisée dans vos différents projets.\nDécoupage du code #Avant de plonger dans le vif du sujet, faisons une petite aparté. La création d’un package NuGet implique la création d’une bibliothèque. Cette bibliothèque contiendra du code, code qui sera amené à évoluer et qui pourrait également avoir ses propres dépendances.\nJe vous encourage vivement à bien structurer votre code, en suivant notamment la séparation standard que l’on retrouve dans .NET : une bibliothèque d\u0026rsquo;abstraction et une bibliothèque d\u0026rsquo;implémentation, comme par exemple :\nMyLib.Abstractions MyLib La bibliothèque d\u0026rsquo;abstraction contiendra toutes les interfaces nécessaires au bon fonctionnement de votre bibliothèque d\u0026rsquo;implémentation, mais sans en connaître les détails. Cette implémentation sera réservée à la seconde bibliothèque. Ne vous inquiétez pas, nous verrons juste après une méthode permettant de publier une ou plusieurs bibliothèques sans problème.\nPour illustrer ce propos, voici un diagramme représentant un exemple de bibliothèque découpée en plusieurs sous-bibliothèques, respectant ainsi la séparation des rôles (principe SOLID), notamment la séparation des interfaces et des implémentations :\nExemple de séparation des librairies Prenons maintenant un exemple d\u0026rsquo;une librairie que vous devez connaître : Microsoft.Extensions.Logging. Il en existe plusieurs, chacune ayant leur role et notamment, dans notre exemple, Microsoft.Extensions.Logging.Abstractions. On retrouve bien les interfaces séparé des implémentations :\nExemple de séparation des librairies avec MS Logging On voit bien ici que les implémentations Logger et LoggerFactory de la librairie Microsoft.Extensions.Logging héritent réciproquement de ILogger et ILoggerFactory d\u0026rsquo;une autre librairie Microsoft.Extensions.Logging.Abstractions.\nBien entendu la bibliothèque Microsoft.Extensions.Logging reférence Microsoft.Extensions.Logging.Abstractions comme un dépendance dans le cas présent. Ça sera la même chose pour nos propres librairies.\nCréation des package Nuget #La création de packages NuGet est relativement simple. Grâce à la CLI .NET, vous pouvez générer tous vos packages NuGet en local ou sur votre CI de manière très simple.\nComme vous l’aurez compris, la plupart des instructions nécessaires ne se feront pas directement dans le code. Elles seront exécutées via le terminal ou la console avec des commandes .NET.\nPour plus de praticité et de scalabilité (utilisation en local et sur une CI), je vous propose d\u0026rsquo;utiliser un script batch permettant l\u0026rsquo;exécution automatique de la génération des packages NuGet :\nwhile getopts v:k: flag do case \u0026#34;${flag}\u0026#34; in v) version=${OPTARG};; k) key=${OPTARG};; esac done dotnet pack \u0026#34;MyLib.csproj\u0026#34; --configuration Release dotnet pack \u0026#34;MyLib.Abstractions.csproj\u0026#34; --configuration Release Ce script est relativement simple :\nIl récupère en paramètres d\u0026rsquo;entrées la version et la clé à utilisé (on ne veut pas hardcodé la clé pour des raisons de sécurité) Il utilise la commande dotnet pack pour chaque librairie Il est maintenant possible de trouver votre fichier nupkg dans chaque dossier \u0026ldquo;bin/Release\u0026rdquo; de chacune de vos librairies. Publication sur GitHub #N\u0026rsquo;oubliez pas qu\u0026rsquo;il est tout à fait possible d\u0026rsquo;utiliser directement vos packages NuGet en local. Vous n\u0026rsquo;avez pas besoin de les publier sur un serveur (GitHub ou autre) si vous travaillez seul ou dans une petite équipe qui ne souhaite pas investir dans un serveur.\nCependant, dans ce guide, nous allons voir comment partager nos bibliothèques en privé au sein de notre organisation, afin que tous ceux qui travaillent avec nous puissent les utiliser.\nHeureusement pour nous, GitHub offre toutes les fonctionnalités nécessaires pour cela.\nPour commencer, rendez-vous dans les paramètres de votre compte GitHub. Ensuite, allez dans \u0026ldquo;Developer settings\u0026rdquo;, puis dans \u0026ldquo;Personal access tokens\u0026rdquo; et enfin dans \u0026ldquo;Tokens (classic)\u0026rdquo;.\nGithub personal access tokens Nous allons maintenant créer un nouveau token. Il aura besoin à minima des permissions suivantes :\ndelete:packages repo write:packages Pour des raisons évidentes de sécurité, il est fortement recommandé de créer des tokens avec le moins de persmission possible. Vous l’aurez compris, il est nécessaire de bien sauvegarder la nouvelle clé générée. Si vous ne voulez pas avoir de soucis, a posteriori : impossible de publier, quelqu’un d’autre à publié à votre place, etc \u0026hellip;\nJe souligne un point évident : ne partagez jamais votre clé d\u0026rsquo;accès avec qui que ce soit, même au sein de votre organisation. Chaque utilisateur doit avoir sa propre clé. Nous allons maintenant modifier le précédent script pour gérer la publication automatique sur GitHub :\ndotnet nuget push \u0026#34;MyLib/bin/Release/MyLib.$version.nupkg\u0026#34; --api-key $key --source \u0026#34;myNuget\u0026#34; dotnet nuget push \u0026#34;MyLib.Abstractions/bin/Release/MyLib.Abstractions.$version.nupkg\u0026#34; --api-key $key --source \u0026#34;myNuget\u0026#34; La commande dotnet nuget push permet cette publication. Vous noterez qu\u0026rsquo;on utilise la paramètre \u0026ndash;source avec cette commande. Elle permet de définir la cible du déploiement. Dans le cas présent il s\u0026rsquo;agit de notre serveur Github.\nMais avant d\u0026rsquo;executer à nouveau notre script, il est important d\u0026rsquo;expliquer à NuGet ce que représente myNuget. Pour cela, ajoutez à la racin de votre projet le fichier nuget.config :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;packageSources\u0026gt; \u0026lt;clear /\u0026gt; \u0026lt;add key=\u0026#34;myNuget\u0026#34; value=\u0026#34;https://nuget.pkg.github.com/MyTeam/index.json\u0026#34; /\u0026gt; \u0026lt;/packageSources\u0026gt; \u0026lt;packageSourceCredentials\u0026gt; \u0026lt;github\u0026gt; \u0026lt;add key=\u0026#34;Username\u0026#34; value=\u0026#34;MyUsername\u0026#34; /\u0026gt; \u0026lt;/github\u0026gt; \u0026lt;/packageSourceCredentials\u0026gt; \u0026lt;/configuration\u0026gt; L\u0026rsquo;URL de votre dépôt NuGet se trouve être toujours être l\u0026rsquo;URL suivante \u0026ldquo;https://nuget.pkg.github.com\u0026rdquo; suffixé avec le nom de votre organisation et /index.json. Vous pouvez maintenant executer à nouveau le script et constaté la présence de votre librairie directement sur votre compte Github !\nAlors maintenant comment les utiliser ?\nUtiliser une librairie custom via Nuget #Pour ceux qui ne seraient pas familiers avec NuGet, il fonctionne de manière similaire à Maven et à d\u0026rsquo;autres gestionnaires de dépendances bien connus sur diverses plateformes. En d\u0026rsquo;autres termes, il existe des serveurs principaux gérés par des grandes entreprises et utilisés automatiquement par différents environnements de développement (IDE). Cependant, il est tout à fait possible d\u0026rsquo;ajouter nos propres sources et de configurer nos propres serveurs NuGet.\nNous allons donc ajouter une nouvelle source de données à notre IDE. Voici des exemples de configuration pour les deux principaux IDE.\nAvec Visual Studio #Avec Visual Studio c\u0026rsquo;est très simple. Rendez-vous dans les paramètres \u0026ldquo;Options\u0026rdquo; \u0026gt; \u0026ldquo;Gestionnaire de packages NuGet\u0026rdquo; et cliquer sur \u0026ldquo;+\u0026rdquo;\nParamètres Visual Studio À partir il ne vous reste plus qu\u0026rsquo;à rentrer les différentes informations demandé et le tour est joué ! Dans le gestionnaire de package NuGet vous verrez votre nouvelle source :\nGestionnaire de package NuGet Avec Rider #Lorsque vous ouvrez votre gestionnaire de dépendances NuGet dans Rider, aller dans l\u0026rsquo;onglet \u0026ldquo;Sources\u0026rdquo;. Ce dernier va vous proposer une liste par défaut de configuration disponibles :\n[Effective NuGet.Config] Et votre propre configuration C\u0026rsquo;est dans cette dernière que nous allons ajouter une nouvelle source. Sélectionné là et cliquer sur le bouton \u0026ldquo;+\u0026rdquo;.\nAjouter une source NuGet Dans certains cas la source n\u0026rsquo;est pas activé par défaut, n\u0026rsquo;oubliez pas de cocher la case \u0026ldquo;Enable\u0026rdquo; pour l\u0026rsquo;utiliser. Vous pouvez maintenant directement voir vos librairies dans votre manager NuGet :\nLibrairies dans le manager NuGet En conclusion, la création et le partage de packages NuGet peuvent grandement faciliter la gestion des dépendances et la réutilisabilité de votre code, que vous travailliez seul ou en équipe. En suivant ces étapes et en adoptant de bonnes pratiques, vous pourrez optimiser vos workflows et améliorer la collaboration au sein de votre organisation.\nEn espérant que cet article vous aura plu, n’hésitez pas à le partager et à revenir nous voir plus tard !\n","date":"26 mai 2024","permalink":"/blog/fr/posts/create_nuget_lib/","section":"Posts","summary":"Que l’on soit seul ou en entreprise, dupliquer du code n’est jamais une bonne pratique.","title":"Créer une librairie NuGet"},{"content":"","date":null,"permalink":"/blog/fr/tags/csharp/","section":"Tags","summary":"","title":"Csharp"},{"content":"","date":null,"permalink":"/blog/fr/tags/dotnet/","section":"Tags","summary":"","title":"Dotnet"},{"content":"","date":null,"permalink":"/blog/fr/categories/net/","section":"Categories","summary":"","title":"NET"},{"content":"","date":null,"permalink":"/blog/fr/tags/nuget/","section":"Tags","summary":"","title":"Nuget"},{"content":"","date":null,"permalink":"/blog/fr/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/blog/fr/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Mais qu\u0026rsquo;est-ce que cette erreur ? Vous avez déjà eu ce moment, devant votre débogueur où vous regarder le message d\u0026rsquo;erreur, vous vous remémorez ce que vous venez de faire que dernières modifications et \u0026hellip; rien. Rien n\u0026rsquo;a de sens.\nvia GIPHY\nJ\u0026rsquo;ai vécu aujourd\u0026rsquo;hui même un tel moment. Je travaille actuellement sur une nouvelle application en .NET MAUI. Je faisais une classe générique pour la gestion des pages de l\u0026rsquo;application. J\u0026rsquo;implémentais cette dernière dans un cas réel et la BOOM 💥 j\u0026rsquo;ai cette erreur qui s\u0026rsquo;affiche sur mon Visual Studio :\nSystem. Reflection. TargetInvocationException: \u0026lsquo;Exception has been thrown by the target of an invocation.\u0026rsquo;\nImpossible de trouver ce que cela pouvait bien être. J\u0026rsquo;ai annulé mes toutes dernières modifications sur Git, mais là encore, pas de changement. Donc sois c\u0026rsquo;est une modification antérieure, soit j\u0026rsquo;ai un plus gros problème.\nSi comme moi vous faites pas mal de .NET, vous avez l\u0026rsquo;habitude de supprimer les dossiers bin et obj qui sont souvent la cause de nombreux problèmes. Bien sûr par réflexe je tente cette astuce : mais toujours rien. Alors cette fois je tente d\u0026rsquo;activer l\u0026rsquo;arrêt automatique du débogueur pour voir exactement où ce situe le problème, en espérant que se problème vient bien de mon code.\nPour faire ça, si vous ne le savez pas, il faut ouvrir le menu Paramètres d\u0026rsquo;exceptions.\nDans ce menu je recherche l\u0026rsquo;exception globale System.Exception et je la coche.\nÀ partir de là je relance l\u0026rsquo;application en mode débug. Et comme vous pouvez le constater par vous-même, l\u0026rsquo;erreur est beaucoup plus explicite !\nIl manquait donc simplement une référence dans mon injection de dépendance automatique :\napplication.builder.Services.AddScoped\u0026lt;IDiscussionRepository, FakeDiscussionRepository\u0026gt;(); Donc rien de bien méchant, mais qui aura occasionné bien des recherches et des tests pour quelque chose de simple. Alors si vous aussi vous vous retrouvez dans une situation comme celle-ci, n\u0026rsquo;hésitez pas à appliquer cette astuce , qui je l\u0026rsquo;espère, vous aidera à gagner pas mal de temps !\nEn espérant vous revoir très vite sur mon blog !\n","date":"2 octobre 2023","permalink":"/blog/fr/posts/dotnet-maui-targetinvocationexception/","section":"Posts","summary":"Mais qu\u0026rsquo;est-ce que cette erreur ?","title":"Allô Huston ... Nous avons un problème"},{"content":"","date":null,"permalink":"/blog/fr/categories/csharp/","section":"Categories","summary":"","title":"Csharp"},{"content":"","date":null,"permalink":"/blog/fr/categories/dotnet/","section":"Categories","summary":"","title":"Dotnet"},{"content":"","date":null,"permalink":"/blog/fr/categories/ios/","section":"Categories","summary":"","title":"IOS"},{"content":"","date":null,"permalink":"/blog/fr/tags/swift/","section":"Tags","summary":"","title":"Swift"},{"content":"","date":null,"permalink":"/blog/fr/tags/swiftui/","section":"Tags","summary":"","title":"Swiftui"},{"content":"Ce n\u0026rsquo;est plus une nouveauté, SwiftUI fait partie de notre écosystème de développeur iOS. Nous avons de plus en plus d\u0026rsquo;opportunité avec cette technologie et il est grand temps de se projeter avec elle.\nDe ce fait lorsque l\u0026rsquo;on crée un nouveau composant graphique on se pose toujours la question : Est-ce que je le crée en SwiftUI pour qu\u0026rsquo;il soit compatible avec l\u0026rsquo;avenir ? Ou est-ce que je le fais avec mon bon vieux UIKit pour être sûr de bien tout maîtriser ? Je pense que beaucoup d\u0026rsquo;entre nous choisissent la seconde option pour plus de facilité, mais aussi parce que SwiftUI permet déjà d\u0026rsquo;incorporer des vues UIKit au sein de SwiftUI.\nJ\u0026rsquo;avais d\u0026rsquo;ailleurs déjà parlé d\u0026rsquo;un sous-ensemble de cette possibilité dans cet article : https://kelvas09.github.io/blog/posts/uikit-view-on-swiftui/ Il est fort à parier que SwiftUI deviendra un jour la principale manière de concevoir des applications pour iOS, iPadOS, macOS et tvOS. Même si UIKit ne disparaîtra jamais selon moi, il est très important d\u0026rsquo;avoir une bonne connaissance et une bonne stack SwiftUI. De ce fait, créer des composants en SwiftUI first semble pertinent.\nHeureusement pour nous, il est assez simple de convertir une vue SwiftUI en vue UIKit.\nDéfinir une vue SwiftUI #Pour commencer, définissons une vue SwiftUI. Pour les besoins de la démonstration cette dernière sera très simple. Bien entendu, peu importe la complexité de votre vue, cela fonctionne pareil :\nimport SwiftUI public struct MyCustomView: View { public let title: String public let tip: String public var body: some View { VStack { Text(title) .font(.title3) Text(tip) .font(.caption) } } } Deux textes l\u0026rsquo;un en dessous de l\u0026rsquo;autre avec une police différente. Très simple, mais largement suffisant pour notre cas.\nIl nous faut maintenant convertir notre vue avec UIKit.\nWrapper la vue SwiftUI dans une vue UIKit #Un peu de code #À vrai dire convertir n\u0026rsquo;est pas le bon mot, embarqué serait le plus exact. Pour rappel, avec UIKit tout est UIView. Il nous faut donc créer une vue capable de contenir notre vue SwiftUI. Pour ce faire et afin d\u0026rsquo;éviter de dupliquer du code, nous allons créer notre propre class UIView capable de faire la conversion à volonté.\npublic class UIMyCustomView: UIView { public init() { super.init(frame: .zero) } override public init(frame: CGRect) { super.init(frame: frame) } @available(*, unavailable) required init?(coder: NSCoder) { fatalError(\u0026#34;init(coder:) has not been implemented\u0026#34;) } public func setup( title: String, tip: String ) { backgroundColor = .clear subviews.forEach { $0.removeFromSuperview() } let myCustomView = MyCustomView(title: title, tip: tip) let viewController = UIHostingController(rootView: myCustomView) guard let swiftUIView = viewController.view else { return } swiftUIView.backgroundColor = .clear swiftUIView.translatesAutoresizingMaskIntoConstraints = false addSubview(swiftUIView) let leading = swiftUIView.leadingAnchor.constraint(equalTo: leadingAnchor) leading.priority = .defaultHigh leading.isActive = true let trailing = swiftUIView.trailingAnchor.constraint(equalTo: trailingAnchor) trailing.priority = .defaultHigh trailing.isActive = true let top = swiftUIView.topAnchor.constraint(equalTo: topAnchor) top.priority = .defaultHigh top.isActive = true let bottom = swiftUIView.bottomAnchor.constraint(equalTo: bottomAnchor) bottom.priority = .defaultHigh bottom.isActive = true } } Pour des raisons évidentes nous rendons transparente notre nouvelle vue et nous supprimons d\u0026rsquo;éventuelles sous vues pré-existantes. Il va de soit également que la méthode setup pouvant être appelé plusieurs fois, il est important de bien toujours nettoyer notre vue pour éviter d\u0026rsquo;empiler les vue SwiftUI.\nÀ partir de là la partie intéressante commence : Nous créons notre vue SwiftUI comme on le ferait dans du code standard. Nous en profitons pour passer les informations nécessaires au bon fonctionnement (ici le titre et le conseil).\nBien sûr il est possible d\u0026rsquo;utiliser des modifiers SwiftUI à ce moment là aussi. Maintenant il nous faut créer un UIHostingController avec en rootView notre vue SwiftUI fraichement créée. Utiliser un UIHostingController permet justement d\u0026rsquo;embarqué notre vue SwiftUI dans un controller UIKit. Et comme vous le savez déjà probablement, chaque UIViewController possède une vue. C\u0026rsquo;est cette dernière que nous allons récupérer et ajouter à notre propre vue.\nIl ne nous reste plus qu\u0026rsquo;à attacher cette vue aux quatre coins de la nôtre et le tour est joué !\nLa preuve en image #struct MyCustomView_Previews: PreviewProvider { static var previews: some View { MyCustomView( title: \u0026#34;This is my title\u0026#34;, tip: \u0026#34;This is my tips\u0026#34; ) } } Avec le code ci-dessus nous optenons le résultat suivant. Il s\u0026rsquo;agit d\u0026rsquo;une vue 100% fait en SwiftUI.\nSwiftUI preview Comme vous pouvez le voir, le rendu est tel qu\u0026rsquo;attendu. Maintenant regardons notre vue incorporée dans une vue UIKit. Le code suivant permet de générer la prochaine photo :\nclass ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) let subview = UIMyCustomView() subview.setup(title: \u0026#34;This is my title\u0026#34;, tip: \u0026#34;This is my tip\u0026#34;) subview.translatesAutoresizingMaskIntoConstraints = false view.addSubview(subview) let leading = subview.leadingAnchor.constraint(equalTo: view.leadingAnchor) leading.priority = .defaultHigh leading.isActive = true let trailing = subview.trailingAnchor.constraint(equalTo: view.trailingAnchor) trailing.priority = .defaultHigh trailing.isActive = true let top = subview.topAnchor.constraint(equalTo: view.topAnchor) top.priority = .defaultHigh top.isActive = true let bottom = subview.bottomAnchor.constraint(equalTo: view.bottomAnchor) bottom.priority = .defaultHigh bottom.isActive = true } } UIKit display Comme vous pouvez le constater le résultat est exactement le même.\nJ\u0026rsquo;espère que vous avez aimé cet article ! N\u0026rsquo;hésitez pas à réagir sur Twitter ou Mastodon ! À bientôt !\n","date":"1 octobre 2023","permalink":"/blog/fr/posts/swiftui_view_inside_uikit_view/","section":"Posts","summary":"Ce n\u0026rsquo;est plus une nouveauté, SwiftUI fait partie de notre écosystème de développeur iOS.","title":"Utiliser une vue SwiftUI dans UIKit"},{"content":"On prend les mêmes et on recommence #Comme vous le savez déjà je suis un développeur mobile français et j\u0026rsquo;aime partager avec vous tous mes connaissances en la matière.\nAfin de toucher le plus grand nombre j\u0026rsquo;ai le plus souvent écrit en anglais. Mais je trouve que la communauté iOS, Android et .NET manque quelque peu de ressources dans notre belle langue.\nC\u0026rsquo;est pourquoi j\u0026rsquo;ai décider de fournir mes articles toujours en anglais pour le plus grand nombre mais aussi en français !\nIl vous est donc possible de changer de langue juste en cliquant sur l\u0026rsquo;un des drapeaux enn haut de chaque page de mon blog.\nComme vous pouvez l\u0026rsquo;imaginer, l\u0026rsquo;écriture en français sera plus simple pour moi, c\u0026rsquo;est pourquoi certains articles sortiront probablement d\u0026rsquo;abord en français mais seront, par la suite, toujours traduit vers l\u0026rsquo;anglais. Concernant les articles existants, ces derniers seront traduit au fur et à mesure en français.\nDe nouveaux formats #Dans les mois qui suivrons je m\u0026rsquo;essayerai aussi à de nouveaux formats d\u0026rsquo;articles : podcast, vidéos, tutoriels animés, \u0026hellip;\nIci aussi ces formats seront traités dans les deux langues.\nÀ très bientôt pour de nouveaux articles !\n","date":"11 mars 2023","permalink":"/blog/fr/posts/new-language/","section":"Posts","summary":"On prend les mêmes et on recommence #Comme vous le savez déjà je suis un développeur mobile français et j\u0026rsquo;aime partager avec vous tous mes connaissances en la matière.","title":"Une nouvelle langue est disponible ! 🇫🇷"}]