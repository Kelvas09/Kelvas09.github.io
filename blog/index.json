[{"content":"But what is this error? Have you ever had that moment, in front of your debugger, when you look at the error message, remember what you\u0026rsquo;ve just done that last modification and \u0026hellip; nothing. Nothing makes sense.\nvia GIPHY\nJust today I experienced such a moment. I\u0026rsquo;m currently working on a new application in .NET MAUI. I was making a generic class for managing the application\u0026rsquo;s pages. I was implementing this in a real case and the BOOM 💥 I get this error displayed on my Visual Studio :\nSystem. Reflection. TargetInvocationException: \u0026lsquo;Exception has been thrown by the target of an invocation.\u0026rsquo;\nI couldn\u0026rsquo;t figure out what it was. I\u0026rsquo;ve undone my latest changes on Git, but again, no change. So either it\u0026rsquo;s an earlier modification, or I\u0026rsquo;ve got a bigger problem.\nIf, like me, you do a lot of .NET, you\u0026rsquo;re used to deleting the bin and obj folders, which are often the cause of many problems. Of course, by reflex I try this trick: but still nothing. So this time I try to activate the debugger\u0026rsquo;s automatic shutdown to see exactly where the problem lies, hoping that it\u0026rsquo;s actually my code.\nTo do this, if you don\u0026rsquo;t know, open the Exception settings menu.\nIn this menu I search for the global exception System.Exception and check it.\nI then run the application again in debug mode. And as you can see for yourself, the error is much more explicit!\nSo my automatic dependency injection was simply missing a reference:\napplication.builder.Services.AddScoped\u0026lt;IDiscussionRepository, FakeDiscussionRepository\u0026gt;(); So it\u0026rsquo;s no big deal, but it will have caused a lot of research and testing for something so simple. So if you too find yourself in a situation like this, don\u0026rsquo;t hesitate to apply this tip, which I hope will help you save a lot of time!\nHope to see you soon on my blog!\n","date":"2 October 2023","permalink":"/blog/posts/dotnet-maui-targetinvocationexception/","section":"Posts","summary":"But what is this error? Have you ever had that moment, in front of your debugger, when you look at the error message, remember what you\u0026rsquo;ve just done that last modification and \u0026hellip; nothing. Nothing makes sense.\nvia GIPHY\nJust today I experienced such a moment. I\u0026rsquo;m currently working on a new application in .NET MAUI. I was making a generic class for managing the application\u0026rsquo;s pages. I was implementing this in a real case and the BOOM 💥 I get this error displayed on my Visual Studio :","title":"Hello Huston ... We have a problem"},{"content":"It\u0026rsquo;s no longer news that SwiftUI is part of our iOS developer ecosystem. We have more and more opportunities with this technology and it\u0026rsquo;s high time to project ourselves with it.\nSo when we create a new graphical component, we always ask ourselves: do I create it in SwiftUI so that it\u0026rsquo;s compatible with the future? Or do I do it with my good old UIKit to make sure I\u0026rsquo;ve got everything right? I think many of us choose the second option for ease of use, but also because SwiftUI already allows UIKit views to be incorporated within SwiftUI.\nI had already mentioned a subset of this possibility in this article: https://kelvas09.github.io/blog/posts/uikit-view-on-swiftui/ It\u0026rsquo;s a safe bet that SwiftUI will one day become the main way of designing apps for iOS, iPadOS, macOS and tvOS. Even if UIKit will never disappear in my opinion, it\u0026rsquo;s very important to have a good knowledge and a good SwiftUI stack. Therefore, creating components in SwiftUI first seems relevant.\nFortunately for us, it\u0026rsquo;s easy enough to convert a SwiftUI view into a UIKit view.\nDefining a SwiftUI view # To begin with, let\u0026rsquo;s define a SwiftUI view. For the purposes of this demonstration, this will be a very simple view. Of course, no matter how complex your view, it works the same:\nimport SwiftUI public struct MyCustomView: View { public let title: String public let tip: String public var body: some View { VStack { Text(title) .font(.title3) Text(tip) .font(.caption) } } } Two texts one below the other in a different font. Very simple, but more than enough for our purposes.\nNow we need to convert our view with UIKit.\nWrapping the SwiftUI view in a UIKit view # A little code # To tell the truth, convert isn\u0026rsquo;t the right word, embedded would be more accurate. As a reminder, with UIKit everything is UIView. So we need to create a view capable of containing our SwiftUI view. To do this, and to avoid duplicating code, we\u0026rsquo;ll create our own UIView class capable of doing the conversion at will.\npublic class UIMyCustomView: UIView { public init() { super.init(frame: .zero) } override public init(frame: CGRect) { super.init(frame: frame) } @available(*, unavailable) required init?(coder: NSCoder) { fatalError(\u0026#34;init(coder:) has not been implemented\u0026#34;) } public func setup( title: String, tip: String ) { backgroundColor = .clear subviews.forEach { $0.removeFromSuperview() } let myCustomView = MyCustomView(title: title, tip: tip) let viewController = UIHostingController(rootView: myCustomView) guard let swiftUIView = viewController.view else { return } swiftUIView.backgroundColor = .clear swiftUIView.translatesAutoresizingMaskIntoConstraints = false addSubview(swiftUIView) let leading = swiftUIView.leadingAnchor.constraint(equalTo: leadingAnchor) leading.priority = .defaultHigh leading.isActive = true let trailing = swiftUIView.trailingAnchor.constraint(equalTo: trailingAnchor) trailing.priority = .defaultHigh trailing.isActive = true let top = swiftUIView.topAnchor.constraint(equalTo: topAnchor) top.priority = .defaultHigh top.isActive = true let bottom = swiftUIView.bottomAnchor.constraint(equalTo: bottomAnchor) bottom.priority = .defaultHigh bottom.isActive = true } } For obvious reasons, we make our new view transparent and remove any pre-existing sub-views. It also goes without saying that since the setup method can be called several times, it\u0026rsquo;s important to always clean up our view to avoid stacking SwiftUI views.\nNow the interesting part begins: we create our SwiftUI view as we would in standard code. We take advantage of this to pass the information needed for proper operation (here the title and the tip).\nOf course it\u0026rsquo;s possible to use SwiftUI modifiers at this point too. Now we need to create a UIHostingController with our freshly created SwiftUI view as rootView. Using a UIHostingController allows you to embed your SwiftUI view in a UIKit controller. And as you probably already know, each UIViewController has a view. It\u0026rsquo;s the latter that we\u0026rsquo;re going to retrieve and add to our own view.\nAll we have to do now is attach this view to the four corners of our own view, and we\u0026rsquo;re done!\nThe proof in the pudding # struct MyCustomView_Previews: PreviewProvider { static var previews: some View { MyCustomView( title: \u0026#34;This is my title\u0026#34;, tip: \u0026#34;This is my tips\u0026#34; ) } } With the above code, we obtain the following result. This is a view 100% made in SwiftUI.\nSwiftUI preview As you can see, rendering is as expected. Now let\u0026rsquo;s take a look at our view embedded in a UIKit view. The following code generates the next photo:\nclass ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) let subview = UIMyCustomView() subview.setup(title: \u0026#34;This is my title\u0026#34;, tip: \u0026#34;This is my tip\u0026#34;) subview.translatesAutoresizingMaskIntoConstraints = false view.addSubview(subview) let leading = subview.leadingAnchor.constraint(equalTo: view.leadingAnchor) leading.priority = .defaultHigh leading.isActive = true let trailing = subview.trailingAnchor.constraint(equalTo: view.trailingAnchor) trailing.priority = .defaultHigh trailing.isActive = true let top = subview.topAnchor.constraint(equalTo: view.topAnchor) top.priority = .defaultHigh top.isActive = true let bottom = subview.bottomAnchor.constraint(equalTo: view.bottomAnchor) bottom.priority = .defaultHigh bottom.isActive = true } } UIKit display As you can see, the result is exactly the same.\nI hope you enjoyed this article! Don\u0026rsquo;t hesitate to react on Twitter or Mastodon! See you soon!\n","date":"1 October 2023","permalink":"/blog/posts/swiftui_view_inside_uikit_view/","section":"Posts","summary":"It\u0026rsquo;s no longer news that SwiftUI is part of our iOS developer ecosystem. We have more and more opportunities with this technology and it\u0026rsquo;s high time to project ourselves with it.\nSo when we create a new graphical component, we always ask ourselves: do I create it in SwiftUI so that it\u0026rsquo;s compatible with the future? Or do I do it with my good old UIKit to make sure I\u0026rsquo;ve got everything right?","title":"Using a SwiftUI view in UIKit"},{"content":"We take the same and we start again # As you already know I am a French mobile developer and I like to share with you all my knowledge in this field.\nIn order to reach as many people as possible I have written most of the time in English. But I find that the iOS, Android and .NET community lacks some resources in our beautiful language.\nThat\u0026rsquo;s why I decided to provide my articles always in English for the greatest number but also in French!\nSo you can change the language just by clicking on one of the flags at the top of each page of my blog.\nAs you can imagine, writing in French will be easier for me, that\u0026rsquo;s why some articles will probably come out in French first but will be, afterwards, always translated into English.Concerning the existing articles, they will be translated into French as we go along.\nNew formats # In the following months I will also try new article formats: podcast, videos, animated tutorials, \u0026hellip;\nHere too, these formats will be treated in both languages.\nSee you soon for new articles!\n","date":"11 March 2023","permalink":"/blog/posts/new-language/","section":"Posts","summary":"We take the same and we start again # As you already know I am a French mobile developer and I like to share with you all my knowledge in this field.\nIn order to reach as many people as possible I have written most of the time in English. But I find that the iOS, Android and .NET community lacks some resources in our beautiful language.\nThat\u0026rsquo;s why I decided to provide my articles always in English for the greatest number but also in French!","title":"A new language is available! 🇫🇷"},{"content":"With Swift 5.5 and the SE-0296 it is now possible to use async / await as in many languages such as C#, Typescript, Javascript or even Rust.\nUntil now we handled asynchronism in three different ways: the delegated as Apple does a lot, closures (also called completionHandler) as many do or with RxSwift or other libraries like Promise.\nBut with the arrival of async / await it is no longer necessary to go through all that. So how to convert existing code, especially libraries, to async / await without rewriting everything?\nIn this article we will see together how to convert delegate and closure to async / await very easily. Regarding libraries like RxSwift or Promise, I let you refer to their different documentations since each of them will have a different implementation.\nThe functioning of a delegate # If you are already familiar with this concept, I invite you to go to the next chapter. If you are not, or if you want to review a bit, please stay here.\nThe delegate is a pattern heavily used by Apple in the core APIs of UIKit. Of course you will find it in many other languages / technologies.\nThe principle is quite simple: an object A performing a processing will notify an object B inheriting from a protocol C of the end of an action or the need to provide information.\nIf we want to express it in UML format, we would obtain this:\n%%{init: {'theme': 'dark', 'themeCSS': 'svg {background-color: black}'}}%% classDiagram ObjectA..\u003eObjectB ObjectB--|\u003eProtocolC The natural example you think of when you\u0026rsquo;ve done UIKit is the UITableViewDelegate that you\u0026rsquo;ve probably implemented dozens of times before:\nclass MyViewController: UIViewController, UITableViewDelegate { ... func tableView(UITableView, viewForHeaderInSection: Int) -\u0026gt; UIView? { ... } ... } In this case, each time the tableView needs the view of a section, it will ask the delegate for this information. Here we are not talking about asynchronism via the delegate at all but only about delegating a decision making.\nWe have the case of asynchronism with the UIImagePickerControllerDelegate which asks for the implementation of the didFinishPickingMediaWithInfo method which will be called when the user has made his selection, the latter may arrive any time in the future.\nThe case of closures # The closure allows to define code with or without parameters that will be executed later. For example when the user login is successful:\nfunc login(username: String, password: String, closure: @escaping (_ error: Error?) -\u0026gt; Void) { MyServer.connect(with: username, password: password) { error in closure(error) } } @IBAction func loginButtonPressed() { let username = \u0026#34;MyUsername\u0026#34; let password = \u0026#34;MyPassword\u0026#34; self.login(username: username, password: password) { [weak self] error in self?.loader.dismiss() if let error = error { self?.displayError(error) } else { self?.navigateToMenu() } } } In this case the closure is used to perform a UI processing when the login is completed successfully or not. The login is dependent on an API request that can take several seconds to transit, so we are in the case of asynchronism.\nIf you do not know the usefulness of [weak self] I invite you to read the present article here. If you want more information about the keyword @escaping, I invite you to read the present article here. The tools provided by Apple # Of course Apple has thought of everything and provided us with tools to convert a delegate or a closure to the async / await pattern. So be careful, when I talk about tools, I\u0026rsquo;m not talking about an application that will take care of the code for you but a new API:\nwithCheckedContinuation and withCheckedThrowingContinuation methods to accomplish this mission:\nfunc withCheckedContinuation\u0026lt;T\u0026gt;( function: String = #function, _ body: (CheckedContinuation\u0026lt;T, Never\u0026gt;) -\u0026gt; Void ) async -\u0026gt; T func withCheckedThrowingContinuation\u0026lt;T\u0026gt;( function: String = #function, _ body: (CheckedContinuation\u0026lt;T, Error\u0026gt;) -\u0026gt; Void ) async throws -\u0026gt; T By analyzing the previous statements you will have understood that the first one does not handle errors while the second one does. Let\u0026rsquo;s see now how to use them.\nProof by example # With a closure # The first advice I can give you is not to replace the existing method with closure by a unique method with async / await but to create an extension.\nLet\u0026rsquo;s go back to our example of the user connection:\nclass Authenticator { func login(username: String, password: String, closure: @escaping (_ error: Error?) -\u0026gt; Void) { MyServer.connect(with: username, password: password) { error in closure(error) } } } extension Authenticator { func loginAsync(username: String, password: String) async throws { try await withCheckedThrowingContinuation({ (continuation: CheckedContinuation\u0026lt;Void, Error\u0026gt;) -\u0026gt; Void in login(username: username, password: password) { error in if let error = error { continuation.resume(throwing: error) } else { continuation.resume() } } }) } } This way you can use both. In the case of async / await it will be possible to use it in the following way:\ndo { try await Authenticator().loginAsync(username: \u0026#34;myUsername\u0026#34;, password: \u0026#34;myPassword\u0026#34;) } catch { print(\u0026#34;An error occurred: \\(error)\u0026#34;) } It is much more elegant and above all you have now the possibility to use one shape or the other according to your projects and your desire!\nWith a delegate # In the case of the delegate it is a little more complicated. It is necessary to encapsulate the delegate in a class and especially to manage the Continuation object well because according to the documentation, this one can be used only once, so it is necessary to make sure that this one is not called 2 times (or more) and is well renewed each time:\nYou must call a resume method exactly once on every execution path throughout the program.\nFor the next example I will take the Bluetooth LE device scan which uses the CBCentralManagerDelegate delegate to notify when a new device is found.\nIt is necessary to add Bluetooth capability to your project for it to work and for the user to access the permission. As a reminder, our goal is simple: to allow Bluetooth LE device scanning from a simple asynchronous method and therefore without implementing the delegate and the discovery management in our view / controller.\nimport Foundation import CoreBluetooth struct BluetoothLEDevice { let identifier: String let name: String init(peripheral: CBPeripheral) { self.identifier = peripheral.identifier.uuidString self.name = peripheral.name ?? \u0026#34;\u0026#34; } } actor BluetoothLEScanWrapper { enum BluetoothLEScanError: Error { case bluetoothNotAvailable } private let bluetoothLEDelegate: BluetoothLEDelegate = BluetoothLEDelegate() private var activeTask: Task\u0026lt;[BluetoothLEDevice], Error\u0026gt;? func scan(for seconds: Double = 3.0) async throws -\u0026gt; [BluetoothLEDevice] { if let existingTask = activeTask { return try await existingTask.value } let task = Task\u0026lt;[BluetoothLEDevice], Error\u0026gt; { guard bluetoothLEDelegate.bluetoothIsOn else { activeTask = nil throw BluetoothLEScanError.bluetoothNotAvailable } self.bluetoothLEDelegate.central.scanForPeripherals(withServices: nil) try await Task.sleep(nanoseconds: (UInt64(seconds) * 1_000_000_000)) let devices = bluetoothLEDelegate.foundPeripheral.compactMap { BluetoothLEDevice(peripheral: $0) } bluetoothLEDelegate.central.stopScan() bluetoothLEDelegate.foundPeripheral = [] activeTask = nil return devices } activeTask = task return try await task.value } private final class BluetoothLEDelegate: NSObject, CBCentralManagerDelegate { let central: CBCentralManager = CBCentralManager() var bluetoothIsOn: Bool = false var foundPeripheral: [CBPeripheral] = [] override init() { super.init() self.central.delegate = self } func centralManagerDidUpdateState(_ central: CBCentralManager) { self.bluetoothIsOn = central.state == .poweredOn } func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { guard !foundPeripheral.contains(where: { $0.identifier == peripheral.identifier }) else { return } self.foundPeripheral.append(peripheral) } } } We can now call in an asynchronous method our scan method which completely abstracts our delegate :\ndo { let devices = try await wrapper.scan() print(\u0026#34;Devices: \u0026lt;\\(devices.count)\u0026gt;\u0026#34;) } catch { print(\u0026#34;An error occured: \\(error)\u0026#34;) } Admit that here too it\u0026rsquo;s much sexier!\nYou have probably noticed that the word class has been changed by the word actor. If you want to know more I advise you to stay around, a new article will come soon to explain the difference between a class and an actor.\nI hope you enjoyed this article. If you want to know more, feel free to check out the rest of the blog or follow me on Twitter or on Reddit.\nSee you soon I hope!\nSources # https://developer.apple.com/documentation/uikit/uiimagepickercontrollerdelegate https://developer.apple.com/documentation/uikit/uitableviewdelegate https://developer.apple.com/documentation/swift/withcheckedcontinuation(function:_:) https://developer.apple.com/documentation/swift/withcheckedthrowingcontinuation(function:_:) https://developer.apple.com/documentation/swift/checkedcontinuation ","date":"21 September 2022","permalink":"/blog/posts/closure-delegate-to-async/","section":"Posts","summary":"With Swift 5.5 and the SE-0296 it is now possible to use async / await as in many languages such as C#, Typescript, Javascript or even Rust.\nUntil now we handled asynchronism in three different ways: the delegated as Apple does a lot, closures (also called completionHandler) as many do or with RxSwift or other libraries like Promise.\nBut with the arrival of async / await it is no longer necessary to go through all that.","title":"Convert a closure or a delegate to async / await"},{"content":"Have you ever crashed your application on purpose? Who would want to do that? What if I told you that there are tools for that and that it can be very useful, do you believe me? Let\u0026rsquo;s take a look at it together!\nassert # If you come from languages like C or C++, assert will be the keyword you are most familiar with. And for good reason, it does exactly the same thing as an assert in C.\nUse this function for internal sanity checks that are active during testing but do not impact performance of shipping code\nAccording to the Apple documentation, assert allows you to test a condition and raise an exception when it is not met. On the other hand a assert instruction is only evaluated in debug.\nPLEASE NOTE! A assert will only be evaluated in a playground or if the -0none build option is present in your project. Here is an example of use:\nfunc IMustReturnTrue() -\u0026gt; Bool { return false } assert(IMustReturnTrue() == false, \u0026#34;Return is invalid\u0026#34;) assertFailure which takes no conditions and will always crash your application :\nlet rndNumber = Int.random(in: 1...10) if rndNumber \u0026lt; 1 || rndNumber \u0026gt; 10 { assertFailure(\u0026#34;Invalid number. Must be between 1 and 10\u0026#34;) } precondition # Use this function to detect conditions that must prevent the program from proceeding, even in shipping code.\nA precondition works exactly the same way as assert, however even in production Swift still executes them and can crash the application. For example:\nprecondition(users.count \u0026gt; 0, \u0026#34;There must be at least one user.\u0026#34;) It is therefore advisable to use it if you always want to have the crash behavior in production. Be careful then with its usage! Here we also find the little brother preconditionFailure which will also raise an exception. It works the same way as precondition for the build configuration part.\nfatalError # fatalError is a message to stop the execution of the current program. It will display a message (if necessary) with the file and line at which the incident occurs.\nfatalError is a Mach exception that will directly stop the execution of the program with the error EXC_BAD_INSTRUCTION. This implies that it is not possible to recover the error with a do\u0026hellip;catch. This statement works for all build configurations.\nA simple example:\nfunc myFunc() { let rndNumber = Int.random(in: 1...3) switch rndNumber { case 1: // Do something case 2: // Do something else case 3: // Do another thing default: fatalError(\u0026#34;Cannot happen!\u0026#34;) } } For more information, please refer to the official documentation from Apple.\nWhy use them? # Crashing is better than not knowing what state you are in # You know as well as I do that to work properly, an application must know its state, must be able to manipulate its data. If at some point the application loses a coherent state, you are out of line and anything can happen: we want to avoid this at all costs.\nIt can be a source of bugs, create potentially annoying side effects for your users, open security holes and many other mishaps are possible. So rather than staying in these states, it is sometimes better that our application crashes.\nWhat\u0026rsquo;s more, with all the crash reporting tools we have nowadays, it\u0026rsquo;s much easier to find out about these errors and fix them for the next release, so is this really a problem? Especially if you have a test team behind you, which will be easier to say: \u0026ldquo;The application crashed\u0026rdquo;, than \u0026ldquo;It was a bit weird there, I don\u0026rsquo;t really know what happened\u0026rdquo;.\nThe case of abstract classes # If you work with Swift and the object model, you know that Swift does not have an abstract class. It is therefore impossible to force the implementation of one or more methods after inheriting them from another class.\nSo by default we create our method and leave it empty. The problem here is that nothing will happen if the developer who inherits your class does not override the method. We want him to do it. This is where the previous instructions come in:\nclass A { func start() { fatalError(\u0026#34;Must be overrided\u0026#34;) } } class B: A { override func start() { // Do something } } This way, we make sure that at runtime an error occurs if the developer has not done the necessary in the code. Granted, this is not as good as a real abstract class since in such a case the compiler would have refused to go further, which is impossible here. But at least we avoid side effects as much as possible.\nI advise you to document your method well to indicate that the method must be overloaded. The developer who will use your code (maybe yourself) will be very grateful. Create an SDK, a library or a framework # No matter what name you give it, creating a reusable library for you or for any other developer is not easy. Especially if this library allows you to reuse code (creation of subclasses) or has a life cycle (startup, registration of the license, \u0026hellip;).\nThere is often a path to follow to initialize your objects for their proper functioning. But what if the developer doesn\u0026rsquo;t respect this? Use a simple message in the logs? Display an intrusive pop-up in the UI of his application?\nPersonally I am not convinced by these methods. For me, the easiest way is to forbid to go further. And for that, there is nothing better than to stop the execution of the program with a fatalError and to validate the provided inputs with a precondition.\nThe message is clear and easy to understand: something is missing. The developer will then be much more careful about how he implements your library. But stay nice and provide documentation 😉.\nHow do I test these instructions? # As we have seen these instructions are very interesting to stop a program or raise an exception in a piece of code that does not have the throw keyword when the conditions are not met.\nHowever as we have also seen, these instructions stop the program and do not propagate the error through the calling stack. It is therefore impossible to catcher these errors with a classic do\u0026hellip;try in Swift.\nNevertheless it remains important to test this kind of behavior when doing unit tests. This is extreme behavior that needs to be checked.\nBut then what happens if such a statement is executed during the unit test run?\nThe test will be in error. Certainly this is what we want, that the error occurs, but it means that our test will always be displayed with a red cross ❌, while we would like it to be validated ✅.\nLet\u0026rsquo;s take a concrete example:\nclass MyBaseClass { /// Call when `start` method is called /// Determine if class is ready /// Must be overrided by each subclass func canStart() -\u0026gt; Bool { fatalError(\u0026#34;Must be overrided\u0026#34;) } } Here I want to validate that my MyBaseClass class raises an exception if I call the default canStart method. So I want to do something like this:\nimport XCTest final class MyBaseClass: XCTestCase { func test_canStart_MustBeOverrided() { let myObject = MyBaseClass() do { myObject.canStart() XCTFail() } catch { // Success! // This is what we want } } } But this will not work! We have seen it before but fatalError does not raise an exception, Swift but stops the program. This implies that we will not be able to catcher our exception. Remember, fatalError is a Mach exception.\nBut then how to do?\nNo choice, we need to get the message issued by fatalError before it stops the application. To make life easier and avoid having to put your hands in Mach, I suggest you use the following package: CwlPreconditionTesting.\nAs you can see in the documentation, its use is very simple:\nimport CwlPreconditionTesting let e = catchBadInstruction { precondition(false, \u0026#34;THIS PRECONDITION FAILURE IS EXPECTED\u0026#34;) } Here all expressions causing a EXC_BAD_INSTRUCTION will then be swallowed by and will no longer cause the program to stop.\nSo it is very important not to use this library directly in your code but only in your tests, otherwise all your fatalError and other will have no effect. Applied to our case, this gives the following code:\nimport XCTest final class MyBaseClass: XCTestCase { func test_canStart_MustBeOverrided() { let myObject = MyBaseClass() let _ = catchBadInstruction { let _ = myObject.canStart() precondition(false, \u0026#34;THIS PRECONDITION FAILURE IS EXPECTED\u0026#34;) } } } And the trick is done! Your test is successful and you are testing the exception correctly. It is important to note, however, that we cannot distinguish between a fatalError and another message producing an EXC_BAD_INSTRUCTION.\nSources # https://developer.apple.com/forums/thread/26939 https://developer.apple.com/documentation/swift/fatalerror(_:file:line:) https://developer.apple.com/documentation/swift/assert(_:_:file:line:) https://developer.apple.com/documentation/swift/precondition(_:_:file:line:) https://cocoacasts.com/what-is-fatalerror-in-swift-and-when-to-use-it https://agostini.tech/2017/10/01/assert-precondition-and-fatal-error-in-swift/ ","date":"16 July 2022","permalink":"/blog/posts/assert-precondition-fatalerror/","section":"Posts","summary":"Have you ever crashed your application on purpose? Who would want to do that? What if I told you that there are tools for that and that it can be very useful, do you believe me? Let\u0026rsquo;s take a look at it together!\nassert # If you come from languages like C or C++, assert will be the keyword you are most familiar with. And for good reason, it does exactly the same thing as an assert in C.","title":"assert, precondition and fatalError"},{"content":"The keyword defer in Swift is not often encountered. Especially when you start developing. Nevertheless it has a certain usefulness and can be very useful.\nDefinition # defer is a Swift keyword used to define code to execute before leaving the current scope:\nfunc changeTitle(_ title: String) { defer { print(\u0026#34;After\u0026#34;) } print(\u0026#34;Before\u0026#34;) myTitleLabel.text = title } At first sight and if we only consider the order in which the instructions are written, we could believe that we will have the following output:\nAfter Before But in reality and as previously mentioned, everything contained in the defer block will be executed afterwards, so we will have the following result:\nBefore After Execution order # It is important to note that it is possible to define several defer blocks in a single method:\nfunc changeTitle(_ title: String) { defer { print(\u0026#34;After\u0026#34;) } defer { print(\u0026#34;After after or After before?\u0026#34;) } print(\u0026#34;Before\u0026#34;) myTitleLabel.text = title } But in what order will the different blocks be executed?\nIt\u0026rsquo;s simple but not very intuitive: in the reverse order of writing. In this case we will have the following output:\nBefore After after or After before? After So fine, but why do it? Let\u0026rsquo;s continue together to better understand the importance of this keyword.\nTry \u0026hellip; catch \u0026hellip; finally # If like me you have been working with C# for a long time, you have probably already used the try...catch...finally syntax. And it\u0026rsquo;s especially this last one finally that we are interested in!\nIn C#, finally allows to execute one or more statements, no matter if the previous code was executed correctly or if an error was encountered. Very useful ! Especially when you have to manage semaphores or disposables.\nBut in Swift this keyword does not exist. So how to do it? You see what I mean, it\u0026rsquo;s thanks to the defer keyword.\nLet\u0026rsquo;s take the case of a WebSocket communication. We want to send a message and whether it works or not, we want to close the WebSocket bridge. If we don\u0026rsquo;t use the defer keyword it would look like this:\nfinal class WebSocketWrapper { func sendMessage(_ message: String) { openBridge() do { try sendMessageOnBridge(message) closeBridge() } catch { closeBridge() } } private func sendMessageOnBridge(_ msg: String) throws { // We send message } private func openBridge() { // We open bridge here } private func closeBridge() { // We close bridge here } } Note that the closeBridge method is called twice. Once if everything goes well and once in the catch in case it didn\u0026rsquo;t go well. And you know as well as I do, duplicating code is never a good idea.\nFortunately with defer it is possible to avoid this:\nfinal class WebSocketWrapper { func sendMessage(_ message: String) { defer { closeBridge() } openBridge() do { try sendMessageOnBridge(message) } catch { // Log } } private func sendMessageOnBridge(_ msg: String) throws { // We send message } private func openBridge() { // We open bridge here } private func closeBridge() { // We close bridge here } } It is now much cleaner!\nMemory management # Of course it is becoming increasingly rare to manage memory with high level languages like Swift, but from time to time it is still the case.\nIf like me you use UnsafeMutablePointer you know that it is necessary to deallocate the memory after its use and this in case of success or failure of the method :\ndo { let pointer = UnsafeMutableRawPointer.allocate( byteCount: byteCount, alignment: alignment) defer { pointer.deallocate() } pointer.storeBytes(of: 42, as: Int.self) pointer.advanced(by: stride).storeBytes(of: 6, as: Int.self) pointer.load(as: Int.self) pointer.advanced(by: stride).load(as: Int.self) let bufferPointer = UnsafeRawBufferPointer(start: pointer, count: byteCount) for (index, byte) in bufferPointer.enumerated() { print(\u0026#34;byte \\(index): \\(byte)\u0026#34;) } } Here, no matter what happens, I know with certainty that my pointer will be deallocated and will not create a memory leak.\nLoops # It is also possible to use defer in a loop statement, for example a for :\nfor i in values { defer { print (\u0026#34;Defer \\(i)\u0026#34;) } print (\u0026#34;Start \\(i)\u0026#34;) print (\u0026#34;End \\(i)\u0026#34;) } In this case the defer will be executed as many times as there are turns in the loop.\nConclusion # And you, in your project, do you need to add defer to simplify or secure your code? I hope this article has been useful and that you have learned something new about Swift.\n","date":"24 June 2022","permalink":"/blog/posts/defer/","section":"Posts","summary":"The keyword defer in Swift is not often encountered. Especially when you start developing. Nevertheless it has a certain usefulness and can be very useful.\nDefinition # defer is a Swift keyword used to define code to execute before leaving the current scope:\nfunc changeTitle(_ title: String) { defer { print(\u0026#34;After\u0026#34;) } print(\u0026#34;Before\u0026#34;) myTitleLabel.text = title } At first sight and if we only consider the order in which the instructions are written, we could believe that we will have the following output:","title":"Swift: defer"},{"content":"I\u0026rsquo;m sure that like me, you have already had strange errors with XCode. What do I mean by \u0026ldquo;strange\u0026rdquo;? Well, the error is not clear and does not seem possible. Let me explain.\nError # I was developing a new SwiftUI application when I got the following error when launching the application on an emulator:\nError: Executable Not found How can the compilation be successful while not finding the executable? Very strange I think. But that was without seeing the little pop-up that opened when clicking on the Details button:\nError code 5 As you can read it indicates that the path to the application is not valid.\nHow to solve the problem? # Clean up the DerivedData folder # My first instinct is always to clean up the DerivedData folder to start over with a clean build, with no steps that could have failed and compromised the application.\nIn this case it didn\u0026rsquo;t work.\nIssue navigator # It is still very strange that the compilation works but not the start of the application, especially when it seems to be corrupted:\nBut if we look at the error panel we find this:\nCompilation errors I don\u0026rsquo;t understand why XCode shows that the build is a success when there are errors but these are already clearer than the previous one. And indeed, when you look at the file explorer, you can see that one is missing:\nMissing files A bad Git manipulation on my part, so no big deal, just put the file back in its place and everything will be back in order.\nConclusion # It is still very strange that XCode shows a success on the compilation of the project while it has errors. But note for later: always look at the issue navigator first.\nSources # https://developer.apple.com/forums/thread/697559 ","date":"3 April 2022","permalink":"/blog/posts/executable_not_found/","section":"Posts","summary":"I\u0026rsquo;m sure that like me, you have already had strange errors with XCode. What do I mean by \u0026ldquo;strange\u0026rdquo;? Well, the error is not clear and does not seem possible. Let me explain.\nError # I was developing a new SwiftUI application when I got the following error when launching the application on an emulator:\nError: Executable Not found How can the compilation be successful while not finding the executable? Very strange I think.","title":"iOS: Executable not found 😨"},{"content":"Recently I was confronted with a code where I saw for the first time the keyword class func. And I must admit, I had no idea what it was about. But as usual I remedied the situation and I wanted to share my discovery with you.\nstatic func # You should already be familiar with static func. If like me you started with languages like C# or Java you already had the opportunity to meet it.\nIt is simply a method accessible directly from a class and not from the instance of a class.\nIt is characterized with code like this:\nfinal class MyClass { static func getData() -\u0026gt; Data { ... } } Nothing very complicated, not to say standard. In the above mentioned languages a class defining a static method and having a child class, this class will inherit the static method. It will be able to use it when needed but in no case redefine it. It is the same thing with Swift.\nBut we will see that it is different with the class func notation.\nclass func # The Swift documentation says this:\nClasses can use the class keyword instead, to allow subclasses to override the superclass’s implementation of that method.\nYou will have understood, unlike static func, it is possible here to override the method marked class func, very convenient in the case of inheritance.\nSo it is possible to do this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyClass { class func doIt() { print(\u0026#34;I\u0026#39;m \u0026lt;\\(self)\u0026gt;\u0026#34;) } } class MySubClass: MyClass { override class func doIt() { print(\u0026#34;I\u0026#39;m a subclass \u0026lt;\\(self)\u0026gt;\u0026#34;) } } MyClass.doIt() MySubClass.doIt() The output is then :\nI\u0026#39;m \u0026lt;MyClass\u0026gt; I\u0026#39;m a subclass \u0026lt;MySubClass\u0026gt; The keyword self # In this particular case the self keyword is not used in the same way as usual:\nWithin the body of a type method, the implicit self property refers to the type itself, rather than an instance of that type. This means that you can use self to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.\nAnd yes in this case we are not in an instance method, therefore self cannot refer to the current instance of the class since it does not exist.\nself therefore refers to the type of the class as in the example below:\nclass MyClass { class func doIt() { print(\u0026#34;I\u0026#39;m \u0026lt;\\(self)\u0026gt;\u0026#34;) } } Conclusion # It is very interesting to have this possibility in Swift, it gives even more perspective for the management in the inheritance of classes. But it must be used wisely.\nSources # https://stackoverflow.com/questions/25156377/what-is-the-difference-between-static-func-and-class-func-in-swift https://holyswift.app/the-difference-between-class-func-and-static-func-in-swift-and-why-polymorphism-matters https://docs.swift.org/swift-book/LanguageGuide/Methods.html ","date":"3 April 2022","permalink":"/blog/posts/static-func-vs-class-func/","section":"Posts","summary":"Recently I was confronted with a code where I saw for the first time the keyword class func. And I must admit, I had no idea what it was about. But as usual I remedied the situation and I wanted to share my discovery with you.\nstatic func # You should already be familiar with static func. If like me you started with languages like C# or Java you already had the opportunity to meet it.","title":"Swift: static func VS class func"},{"content":"In a previous article I told you about the keyword @escaping which is very useful in case of a scope change. If you want to know more about it, I invite you to read the article I previously wrote here :Swift: @escaping.\nBut the change of scope leads to other consequences for the values \u0026ldquo;shared\u0026rdquo; potentially by the two scopes.\nBefore talking about weak and unowned it is important to go back to some important notions.\nARC or Automatic Reference Counting # The Automatic Reference Counting or ARC for the friends allows the management of the memory by releasing it when an instance is no longer referenced:\nSwift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.\nIt is important to note that by default in Swift a reference is noted as strong. final class MyViewController: UIViewController { let repository = MyRepository() } In this case, MyViewController has a strong reference to repository.\nTo learn more, I recommend you to read the following documentation: https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html\nThe case of the strong reference cycle # As you may have understood, the ARC will then deallocate memory from the instances when they no longer have a reference.\nBut what happens when two objects (A and B) have a strong reference to each other?\n%%{init: {'theme': 'dark', 'themeCSS': 'svg {background-color: black}'}}%% graph LR; Soldier--\u003e|Strong reference|Weapon Weapon--\u003e|Strong reference|Soldier In this case ARC will not be able to deallocate memory, which will create a memory leak.\nThis case happens very often if you create a delegate that is not well annotated:\nprotocol MyDelegate { func myFunction() } class MyViewController : UIViewController { var delegate: MyDelegate? = nil } Here MyViewController and its delegate MyDelegate are strong references to each other.\nOf course, this is where weak and unowned come in.\nweak # The case of weak is quite simple and speaks for itself: it is a weak reference and therefore can be deallocated by ARC even if it still has a reference.\n%%{init: {'theme': 'dark', 'themeCSS': 'svg {background-color: black}'}}%% graph LR; Soldier--\u003e|Strong reference|Weapon Weapon-.-\u003e|Weak reference|Soldier This also implies that a weak reference cannot be used with the let keyword since it will at some point be passed to nil.\nweak with let create compilation error The weak variables are then very useful when you can have a strong reference cycle.\nIf we analyze the code of an UITableView you will notice that all delegates (delegate and dataSource) are both annotated with weak for their declaration:\n@available(iOS 2.0, *) open class UITableView : UIScrollView, NSCoding, UIDataSourceTranslating { // ... weak open var dataSource: UITableViewDataSource? weak open var delegate: UITableViewDelegate? // ... } So I can only recommend that you do the same with your delegates. But this may cause you some problems:\nprotocol MyDelegate { func myFunction() } class MyController { weak var delegate: MyDelegate? } And then it\u0026rsquo;s the drama: **Impossible to compile!\nweak with protocol compilation error To solve the problem nothing very complicated. Just add an inheritance to class to your protocol :\nUse a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics. For more about reference and value semantics, see Structures and Enumerations Are Value Types and Classes Are Reference Types.\nWhich translates into this:\nprotocol MyDelegate: class { func myFunction() } class MyController { weak var delegate: MyDelegate? } unowned # A unowned variable is very similar to a weak variable with one difference: the compiler makes sure that the variable in question will not be nil when accessed.\nBut why use unowned instead of weak? According to Apple, here is the reason:\nLike a weak reference, an unowned reference doesn’t keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime. You indicate an unowned reference by placing the unowned keyword before a property or variable declaration.\nIn short, if your objects have the same lifetime, it is better to use unowned and not weak. Let\u0026rsquo;s take a concrete example. In the previous case we had a soldier and his weapon. A soldier owns a weapon, but the weapon can still exist even if the soldier dies. These two classes have a weak reference.\nBut now let\u0026rsquo;s take the case of a character and his skills (for those who like role playing games). A character has several skills. These evolve with the character.\nHowever, when the character dies, the skills disappear with him. They do not continue to exist. They have the same life span as the character.\n%%{init: {'theme': 'dark', 'themeCSS': 'svg {background-color: black}'}}%% graph LR; Player--\u003e|Strong reference|Skill Skill-.-\u003e|Unowned reference|Player From a code point of view, this is what it looks like:\nclass Player { let name: String let skill: Skill? init(name: String) { self.name = name } } class Skill { let power: Int unowned let player: Player init(power: Int, player: Player) { self.power = power self.player = player } } The case of closures # Despite the arrival of async / await there is still a lot of code with closures which were and still are very useful to handle asynchronism.\nBut then what happens in the case of a closure?\nA closure can capture variables or properties of a class, especially when it is @escaping. It is therefore important to manage the ARC correctly.\nThe same rules apply for weak and unowned: if the lifecycle of both classes is the same, unowned should be used, otherwise weak should be preferred.\nfinal class Authenticator { static let shared: Authenticator = Authenticator() func logInAsync(username: String, password: String, closure: @escaping ((_ error: Error?)-\u0026gt;())) { // Some code ... } func signUpAsync(username: String, password: String, closure: @escaping ((_ error: Error?)-\u0026gt;())) { // Some code ... } } final class MyViewController : UIViewController { @IBAction func login() { Authenticator.shared.logInAsync(\u0026#34;myUsername\u0026#34;, \u0026#34;myPassword\u0026#34;) { [weak self] (error: Error?) in // ... } } } As you can see in the previous code we use weak and not unowned because the Authenticator singleton does not have the same lifetime as the MyViewController class.\nOn the other hand in the following code we prefer to use unowned because both classes have the same lifetime:\nfinal class UserRepository { func logInAsync(username: String, password: String, closure: @escaping ((_ error: Error?)-\u0026gt;())) { // Some code ... } func signUpAsync(username: String, password: String, closure: @escaping ((_ error: Error?)-\u0026gt;())) { // Some code ... } } final class LoginViewController : UIViewController { let repository = UserRepository() @IBAction func login() { repository.logInAsync(username: \u0026#34;myUsername\u0026#34;, password: \u0026#34;myPassword\u0026#34;) { [unowned self] (error: Error?) in // ... } } } Note that in both cases we do exactly the same thing, but the lifetime is different and that changes everything in this case.\nIt is also possible to chain the arguments if you have several variables or properties that have been captured by the scope and their cycle is different or not:\nfinal class UserManager { static let shared: UserManager = UserManager() } final class LoginViewController : UIViewController { let userManager = UserManager.shared let repository = UserRepository() @IBAction func login() { repository.logInAsync(username: \u0026#34;myUsername\u0026#34;, password: \u0026#34;myPassword\u0026#34;) { [unowned self, weak userManager] (error: Error?) in // ... } } } Debugging a memory leak # As you may have understood, the keywords weak and unowned allow to avoid memory leaks. But then how to debug them?\nThe simplest tool you can use is the print in the init and deinit methods of your various objects:\nclass MyClass { init() { print(\u0026#34;MyClass is being initialized\u0026#34;) } deinit { print(\u0026#34;MyClass is being deinitialized\u0026#34;) } } And don\u0026rsquo;t forget to watch the memory in XCode :\nXCode memory pane In a future article we will see how to use more powerful tools provided by XCode to help you.\nConclusion # As you can see the devil is in the details. You can use closures and make strong cyclic references without knowing it and not have any problem.\nBut when it becomes critical it can be hard to correct these problems. So let\u0026rsquo;s stay vigilant.\nSources # https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html https://docs.swift.org/swift-book/LanguageGuide/Protocols.html ","date":"25 March 2022","permalink":"/blog/posts/ios_weak_unowned/","section":"Posts","summary":"In a previous article I told you about the keyword @escaping which is very useful in case of a scope change. If you want to know more about it, I invite you to read the article I previously wrote here :Swift: @escaping.\nBut the change of scope leads to other consequences for the values \u0026ldquo;shared\u0026rdquo; potentially by the two scopes.\nBefore talking about weak and unowned it is important to go back to some important notions.","title":"Swift: weak and unowned"},{"content":"It\u0026rsquo;s all in the title: have you ever had this problem? It\u0026rsquo;s still very strange. And it looks like this:\nXCode: Build failed but no errors What\u0026rsquo;s going on? # After several searches it turns out that if you want to have more information on the errors in question, you have to go to the \u0026ldquo;Report navigator\u0026rdquo; which is the last icon in the left sidebar of your screen.\nXCode: Report navigator As you can see there is much more information here than before. The problem comes from the compilation of a file whose module is not known.\nSo why does XCode not display anything?\nWhy this behavior? # Well, by default XCode displays only the errors coming from the current target. In the current case my worksapce is composed of 4 projects:\nAn iOS project in SwiftUI (executable) A macOS project in AppKit (executable) 2 Swift Packages (not executable) So I have 2 schemes : iOS and macOS. The error being present in one of the Swift Package, XCode does not display any error despite the fact that the build fails.\nHow can we change this behavior? # But then how do you change that? Since I work on all these projects at the same time, I would like to have all the errors and not only the errors of the current scheme.\nNothing very complicated here, you just have to go into the project settings. To do this go to the File menu in XCode and select Workspace Settings... :\nXCode: Workspace settings menu Et maintenant il faut changer Show issues for active scheme only en Show all issues :\nXCode: Workspace settings From there you will see all the errors in your project.\nAll errors are now displayed Nothing very complicated but you can easily spend some time there.\nSources # https://stackoverflow.com/questions/14625389/xcode-build-failed-but-no-error-messages https://stackoverflow.com/questions/44608646/xcode-project-build-failed-with-no-errors/44609224 ","date":"13 March 2022","permalink":"/blog/posts/build_failed_without_errors/","section":"Posts","summary":"It\u0026rsquo;s all in the title: have you ever had this problem? It\u0026rsquo;s still very strange. And it looks like this:\nXCode: Build failed but no errors What\u0026rsquo;s going on? # After several searches it turns out that if you want to have more information on the errors in question, you have to go to the \u0026ldquo;Report navigator\u0026rdquo; which is the last icon in the left sidebar of your screen.\nXCode: Report navigator As you can see there is much more information here than before.","title":"XCode: Build failed without any errors 🤔"},{"content":"Repetitive actions are dangerous. Especially if they are simple. We tend to pay less and less attention to them and in the end, we make mistakes. Fortunately it is possible, not to say recommended, to automate these actions.\nSo today, as you may have guessed, we\u0026rsquo;re going to change the theme a bit and talk about the pipeline on GitHub Actions.\nThe context # I love to write and share, therefore I have this technical blog allowing me to pass on what I learn and what I think is useful to others. My blog is built with Hugo a framework written in go that allows you to design static sites very simply while keeping a great customization. In the same genre, you may know Jekyll.\nIt is very simple to start a hugo site\nhugo new site myBlog Just as it is easy to generate the static version of the site :\nhugo This last action generates a public folder containing all the code of my blog. As you can see it is html, css and images files that compose all the pages and articles I wrote until now.\nNow I have to publish this new version of my blog to make it accessible. I didn\u0026rsquo;t want to pay a monthly fee to have a server at a hosting company and have to secure and maintain it. I needed something simple and free in the ideal.\nFortunately GitHub offers GitHub pages. So thanks to my account I have access to a server that can contain static code. So no database, no code to compile (PHP, C#, Swift or other), just html, css and possibly JS files. And it\u0026rsquo;s perfect because Hugo does exactly that.\nThe manual process # Of course, I have started to do the writing and publishing automatically for my blog. The first thing to do is simple: write a new article. I compose my file in markdown format, then I publish with the hugo command, I copy the content of the public folder that I paste in the folder of my repository containing my GitHub Page. I push the changes and after a few moments the new version of my site is available.\nYou will notice that all these tasks, except the writing of the article, can be automated. They are also a source of errors:\nIf I don\u0026rsquo;t copy the right version of my site, the new article will not be available online. If I forget to run the hugo command I won\u0026rsquo;t generate the new version of my blog. If I forget to push or I push on the wrong branch the result will still not be good. Also, let\u0026rsquo;s face it, it\u0026rsquo;s a pain in the ass. My brain is absolutely not stimulated by these actions and so during this (short) time I get bored. So I might as well have someone else do it, or rather a machine.\nMoreover it doesn\u0026rsquo;t solve the problem to write several articles at the same time. Being on a git, I can afford to make several branches, each one having an article being written. If I mismanage my git and create a new version of my blog on the branch of the article and not on develop after a merge, I may delete a published article without wanting to.\nWe need to automate all this.\nWe automate the whole process # It would be easy to automate all this with a script on my machine. I could make a Python or Swift script executing these actions when I need it. But this poses several problems:\nThe script will only be present on one of my machines or I have to duplicate it and be careful when I make changes. The script will be made in a language that may not be executable everywhere : I want to be able to write an article anywhere on anything and be able to publish it The PATH should be always good on all machines to publish in the right repository. A lot of complexity for something simple. But remember, we are on GitHub and we have access to GitHub Actions. So that\u0026rsquo;s what we\u0026rsquo;ll use to solve our problem.\nDefinition # As a reminder the GitHub Actions are :\nGitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.\nIt is a sequence of actions driven by an event. Here is a simple example provided by GitHub:\nGithub Actions Simple. The image is the property of GitHub We can define actions with a YAML file like this one for Swift:\nname: Swift on: [push] jobs: build: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Build run: swift build - name: Run tests run: swift test We just need to define the name of the pipeline, the event(s) that trigger it, where we execute our pipeline (macOS, linux, \u0026hellip;) and the different steps. In this case:\ncheckout build test Of course for us it will not be the same.\nOur need # We need to translate our manual actions into GitHub actions and define who will do what.\n%%{init: {'theme': 'dark', 'themeCSS': 'svg {background-color: black}'}}%% sequenceDiagram GitHubAction-\u003e\u003e+Blog: Checkout code Blog--\u003e\u003e-GitHubAction: Send source code GitHubAction-\u003e\u003eGitHubAction: Install latest hugo's version GitHubAction-\u003e\u003eGitHubAction: Build blog GitHubAction-\u003e\u003e+GitHubPage: Deploy GitHubPage--\u003e\u003e-GitHubAction: Send error code As you can see, there is nothing very complicated here. Let\u0026rsquo;s see what we can do now.\nDefine the YAML file # Let\u0026rsquo;s start by defining the basis of any YAML file for GitHub Actions: the name, the events allowing its triggering.\nFor the name let\u0026rsquo;s keep it simple. We want to publish a new article automatically, so we\u0026rsquo;ll take : Auto publish post\nAs for the events, what can we do? First of all let\u0026rsquo;s remember that we want to publish an article when it has been validated. There is nothing better than PR to validate code, whether it is done in Swift, in Go or in Markdown. The publishing process should only be triggered when there is a merge on the main main branch.\nname: Auto publish post on: push: branches: - main The first job # Checkout source code # It goes without saying that it is necessary to get the source code before doing anything. Of course GitHub has provided the necessary for that, you just have to call the following command :\n- uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 Since our pipeline is on the repository containing the code for our site, you don\u0026rsquo;t need to get the code from another repository. This one will suffice.\nI purposely added submodules in the checkout command because some of you will be using Hugo themes via submodules.\nInstall Hugo on the pipeline # Before generating our site we need to get our Hugo dependency and install the necessary. As on any machine, we have to download the binary and install it, but as Hugo is dependent on Go we have to install this dependency too.\nFortunately for us there is already a developer who has done the necessary for us, I present you peaceiris !\n- name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true This plugin will allow us to save a lot of time while avoiding to write scripts ourselves. For Hugo\u0026rsquo;s version, I advise you to put the version you use locally to have the same behavior as when you test on your machine.\nGenerate the static site # Now that we have our version of Hugo, we can generate our site. To do this, nothing could be simpler, it is the same command as on your local machine:\n- name: Build run: hugo --minify Here I added the argument --minify but nothing mandatory.\nDeploy the new version of the site # It only remains for us to deploy our site. And this is the most complicated part since we want to deploy on another repository. Here again we will use the command provided by peaceiris which will save us a lot of time:\n- name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} publish_dir: ./public destination_dir: ./blog external_repository: MyUser/MyUser.github.io user_name: \u0026#39;MyUser[bot]\u0026#39; user_email: \u0026#39;MyUser[bot]@users.noreply.github.com\u0026#39; full_commit_message: \u0026#34;🗞 Publish a new post!\u0026#34; publish_branch: main publish_dir allows you to define the folder to publish or more precisely the contents of the folder to publish. destination_dir allows you to define the destination folder external_repository allows you to define the target GitHub repository user_name and user_email allows you to define the information of the user publishing the new version publish_branch the target branch full_commit_message represents the commit message However the most important part here without which nothing will work is the deploy_key field. You will have to create a new key without password that we will add to the target repository. To do this you just need to run the following command on your machine:\nssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f my_new_key -N \u0026#34;\u0026#34; This command will generate 2 files:\nmy_new_key.pub which is the public key my_new_key which is the private key If you want more information, I let you visit the README of the peaceiris repository which contains all the information. And a very big thank you to him for these commands!\nFirst add your public key in the Deploy key section of the target repository parameters:\nDeploy public key And then it will be necessary to add in the secrets of the repository containing the sources of your site the private key :\nAdd private key to secret From there it will be possible for the plugin to publish changes in your target repository. Here is the complete code of the pipeline:\nname: Auto publish post on: push: branches: - main jobs: BuildAndPublish: runs-on: ubuntu-latest steps: - run: echo \u0026#34;🎉 The job was automatically triggered by a ${{ github.event_name }} event.\u0026#34; # First we fetch sources - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 # Then we install hugo binary with specific version - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # We build blog - name: Build run: hugo --minify # We deploy to github pages - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} publish_dir: ./public destination_dir: ./blog external_repository: MyUser/MyUser.github.io user_name: \u0026#39;MyUser[bot]\u0026#39; user_email: \u0026#39;MyUser[bot]@users.noreply.github.com\u0026#39; full_commit_message: \u0026#34;🗞 Publish a new post!\u0026#34; publish_branch: main How to test? # The main branch # If this is your first time with GitHub Actions, you may not yet be aware that you can\u0026rsquo;t run actions anywhere other than the main branch of your repository, which by default is the main' branch, or master\u0026rsquo; if your repository is a bit old. But we don\u0026rsquo;t necessarily want to test on this branch. Especially if it is a public repository.\nTo do this I advise you to temporarily change your main branch for the branch on which you develop your pipeline.\nFor those who don\u0026rsquo;t know, you have to go in the parameters of your repository (in red here):\nGithub branches settings Once on the page you can select a new branch (in red here):\nGithub change branches settings Manual launch # By default a pipeline cannot be started manually. For this you will need to add the following piece of code:\nworkflow_dispatch: This will result in something like this:\nname: Auto publish post on: workflow_dispatch: push: branches: - main But I advise you not to leave it once your script is tested and validated. Leaving the possibility to launch the pipeline whenever we want is not relevant since we want to publish articles and these are managed on separate branches.\nMoreover, we used the on.push event which means that if you merge a branch into main or if you push something on this branch the pipeline will be activated.\nSources # https://github.com/features/actions https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow https://github.com/peaceiris/actions-gh-pages https://github.com/peaceiris/actions-hugo ","date":"12 March 2022","permalink":"/blog/posts/auto-publish-with-actions/","section":"Posts","summary":"Repetitive actions are dangerous. Especially if they are simple. We tend to pay less and less attention to them and in the end, we make mistakes. Fortunately it is possible, not to say recommended, to automate these actions.\nSo today, as you may have guessed, we\u0026rsquo;re going to change the theme a bit and talk about the pipeline on GitHub Actions.\nThe context # I love to write and share, therefore I have this technical blog allowing me to pass on what I learn and what I think is useful to others.","title":"Publish automatically Hugo blog with GitHub Actions"},{"content":"Last weekend had started as always: I wanted to learn something new. And that day I wanted to discover console applications in Swift. I\u0026rsquo;ve read a lot of interesting articles on the subject and I\u0026rsquo;ll be sure to tell you about it in my own articles very soon.\nIf you have already done iOS or macOS development you already know that the entry point is the AppDelegate or the SceneDelegate.\nBut what about a console application?\nWell, it\u0026rsquo;s simply the main.swift file. But this one has some particularities. Let\u0026rsquo;s have a look at it.\nThe basic problem # When I created my Swift Package project for my console application, I naturally created a Main.swift file respecting the file naming nomenclature (with capitalization).\nI write my code inside :\nimport Foundation import ConsoleKit let console: Console = Terminal() let input = CommandInput(arguments: CommandLine.arguments) let context = CommandContext(console: console, input: input) var commands = Commands(enableAutocomplete: true) commands.use(AboutCommand(), as: AboutCommand.name, isDefault: true) do { let group = commands.group(help: \u0026#34;Test\u0026#34;) try console.run(group, input: input) } catch { console.error(\u0026#34;\\(error)\u0026#34;) exit(1) } But during the compilation it does not go well:\nCompilation error We obtain the following two errors:\nExpressions are not allowed at the top level and\nStatements are not allowed at the top level But why?\nFor those who don\u0026rsquo;t want to wait until the end, it\u0026rsquo;s because the Main.swift file has a capital letter and not a lower case as expected: main.swift.\nYou will have the same problem if you name your file something other than main.swift.\nNow let\u0026rsquo;s see why. According to the Apple documentation that can be found here we have the following sentence:\nTop-level code is not allowed in most of your Swift source files. For clarity, any executable statement not written within a function body, within a class, or otherwise encapsulated is considered top-level. We have this rule because if top-level code were allowed in all your files, it would be hard to determine where to start the program.\nThe reason is understandable and logical.\nThe case of a Playground file # Note that in a playground within XCode there is no problem to put this type of code, even if your playground is not called main.\nTop-level code on playground This case is also explained in the previous post:\nBecause playground files do support the execution of top-level code. Code within a playground file is order-dependent, run in top-down lexical order. For example, you can’t use a type before you define it.\nEverything depends on whether the files of your project are dependent on an order or not. Note on the other hand that if you add source files to your playground, they will not be able to have top-level code:\nTop-level code on non main file The case of Swift playground # For Swift playground the behavior is identical to an XCode playground file.\nAs long as your top-level code is present in the Main part of your playground there will be no problem:\nTop-level on main file But then again, in another module it won\u0026rsquo;t work:\nTop-level on non main file Le cas des fichiers script Swift # You probably know this but you can directly execute Swift code from your terminal by adding the following code to your :\n#!/usr/bin/xcrun swift or by calling the following command:\nxcrun swift file.swift For this type of case it is quite possible to use top-level code because it is a script. The execution is simple, the entry point is the launched file.\n@main # Since Swift 5.3 you may have noticed that a new annotation exists:\nimport UIKit @main class AppDelegate: UIResponder, UIApplicationDelegate { ... } This annotation forces the class or structure that has it to have a static main() method. This method will be called automatically when the application is started.\n@main error This avoids having a main.swift file and/or top-level code. Quite handy! This means that my base code can evolve and use @main:\nimport Foundation import ConsoleKit @main class Application { static func main() { let console: Console = Terminal() let input = CommandInput(arguments: CommandLine.arguments) let context = CommandContext(console: console, input: input) var commands = Commands(enableAutocomplete: true) commands.use(AboutCommand(), as: AboutCommand.name, isDefault: true) do { let group = commands.group(help: \u0026#34;Test\u0026#34;) try console.run(group, input: input) } catch { console.error(\u0026#34;\\(error)\u0026#34;) exit(1) } } } It is interesting to note that the compiler will always check that you have only one possible entry point and that it is done via a main.swift file or via the @main decorator.\nThis new annotation is the direct descendant of @UIApplicationMain and @NSApplicationMain.\nBut don\u0026rsquo;t be mistaken, whether it is @main, @UIApplicationMain or @NSApplicationMain it is only syntactic sugar that will allow your compiler to generate the main.swift file for you.\nSources # https://developer.apple.com/swift/blog/?id=7 https://github.com/apple/swift-evolution/blob/main/proposals/0281-main-attribute.md https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626 https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID352 ","date":"11 March 2022","permalink":"/blog/posts/file-main/","section":"Posts","summary":"Last weekend had started as always: I wanted to learn something new. And that day I wanted to discover console applications in Swift. I\u0026rsquo;ve read a lot of interesting articles on the subject and I\u0026rsquo;ll be sure to tell you about it in my own articles very soon.\nIf you have already done iOS or macOS development you already know that the entry point is the AppDelegate or the SceneDelegate.","title":"The main.swift special file and the entry points"},{"content":"Do you know the @escaping statement in Swift? The compiler creates an error asking you to add it but you don\u0026rsquo;t know why?\nDon\u0026rsquo;t worry, we\u0026rsquo;ll figure it out together.\nThe notion of asynchronism # With the latest versions of Swift, it is possible to use the async and await keywords to handle asynchronism in our application. But if you have coded applications with older versions of Swift, you probably use closures/callbacks for your asynchronous methods:\nfunc getData(closure: @escaping ((_ data: Data?, _ error: Error?)-\u0026gt;())) { ... } In this piece of code we\u0026rsquo;re going to call a method that is itself asynchronous to retrieve remote data and therefore with a certain delay.\nIf we use URLSession we could have a code like this one:\nimport Foundation func getData(closure: ((_ data: String?, _ error: Error?)-\u0026gt;())) { let url = URL(string: \u0026#34;https://www.myWebsite.com/myApi\u0026#34;)! let task = URLSession.shared.dataTask(with: url) { data, response, error in if let error = error { closure(nil, error) return } if let data = data, let string = String(data: data, encoding: .utf8) { closure(string, nil) } } task.resume() } But why @escaping? # You note that in the above code it is necessary to use @escaping without which the compiler displays this error:\nBut then how does this call differ from this one:\nfunc filter(values: [String], closure: ((_ value: String) -\u0026gt; Bool)) -\u0026gt; [String] { var result: [String] = [] for value in values { let isValid = closure(value) if isValid { result.append(value) } } return result } In both cases we use a closure but then why in one case we need @escaping and not in the other?\nThe scope # In the case of our backward method the closure is not marked as @escaping because the closure is used directly by our method. It does not change scope.\nOn the other hand it is the case for our method getData. We give our closure to another scope. This one will change scope. We then say that it escapes from its scope because it continues to exist after the method has been run.\nThe compiler then needs to know that the closure will leave its original scope and that we know how to manage the particular cases that result from this: access to the self variable within the closure for example.\nThe case of self in an escaped closure # As we said before, a closure noted @escaping will continue to exist after the end of the method.\nNow a closure is simply an anonymous method owned by a class and which can therefore call the self variable at will.\nBut at what risk?\nUnlike a non-escaped closure, it is necessary to specify self before any method or property belonging to the class containing the closure.\nWhy is this?\nWell, simply because self becomes a reference to the scope and must be retained, this is what we call strong references.\nLet\u0026rsquo;s take a simple example:\nclassDiagram class RecipeViewModel { + onRefresh() } class RecipeRepository { + getRecipes(closure: @escaping ...) } RecipeViewModel \"0\" --\u003e \"1\" RecipeRepository: own The RecipeViewModel class therefore has an instance of the RecipeRepository class. The latter is responsible for communicating with the API to retrieve the data we are interested in.\nLet\u0026rsquo;s start by defining our repository:\nfinal class RecipeRepository { func getData(closure: @escaping ((_ data: String?, _ error: Error?)-\u0026gt;())) { let url = URL(string: \u0026#34;https://www.myWebsite.com/myApi\u0026#34;)! let task = URLSession.shared.dataTask(with: url) { data, response, error in if let error = error { closure(nil, error) return } if let data = data, let string = String(data: data, encoding: .utf8) { closure(string, nil) } } task.resume() } } Information Note that the closure is noted @escaping. When calling the onRefresh method of the viewModel, the data will be retrieved:\nfinal class RecipeViewModel { private let repository: RecipeRepository init(repository: RecipeRepository) { self.repository = repository } func onRefresh() { repository.getData { (data: String?, error: Error?) in guard let data = data else { self.displayError() return } self.updateUI(with: data) } } private func displayError() { // Do something } private func updateUI(with data: String) { // Do something } } As you can see we use self in the closure. This is a strong reference to our closure, so this element must not be deallocated until the end of the closure. RecipeViewModel becomes a strong reference to RecipeRepository.\nAs it is, we master both the RecipeRepository and RecipeViewModel classes, so it is very easy to manage the life cycle of these objects. This is much less obvious when using a class that does not belong to you.\nThis notion of strong reference can be avoided / bypassed by the weak and unowned keywords that we will see in a next article!\nConclusion # As you can see, it is quite easy to add a simple @escaping without properly handling all the consequences of this addition.\nIf possible, I advise you to use async / await to stay as up-to-date as possible. We will have the opportunity to see this in a future article. If you want to know more about weak et unowned you can read my other post here.\n","date":"3 March 2022","permalink":"/blog/posts/ios-escaping/","section":"Posts","summary":"Do you know the @escaping statement in Swift? The compiler creates an error asking you to add it but you don\u0026rsquo;t know why?\nDon\u0026rsquo;t worry, we\u0026rsquo;ll figure it out together.\nThe notion of asynchronism # With the latest versions of Swift, it is possible to use the async and await keywords to handle asynchronism in our application. But if you have coded applications with older versions of Swift, you probably use closures/callbacks for your asynchronous methods:","title":"Swift: @escaping"},{"content":"UIKit ViewController with SwiftUI # If you are curious like me, you must have tested SwiftUI. Personally I like this framework more and more. But I will tell you about my feedback in another article. However I have to reproach it for something: it still lacks a lot of things!\nAnd yes, SwiftUI tries to join all the worlds (iOS, macOS, \u0026hellip;) in one. The problem is that the task is not easy. As a result, there are still elements missing that could be crucial to get an experience equal to the one that an iOS application made with UIKit can provide.\nAs you can see, in this article we will focus on the ViewController of the application. SwiftUI provides a lot of user controls that can be used out-of-the-box by developers: Button, Image, Link, List, \u0026hellip;\nHowever some are missing! For example, displaying a modal for entering an email is impossible on SwiftUI. Well, impossible if you don\u0026rsquo;t do it yourself.\nWe will see together how to integrate this page in SwiftUI.\nUIViewControllerRepresentable # This protocol is the basis of all SwiftUI views using UIKit ViewControllers. It allows to create, update and stop UIKit ViewControllers within SwiftUI views:\nprotocol UIViewControllerRepresentable : View where Self.Body == Never We will need it to create our own views.\nFor more information, please visit here.\nHow it works # Implement UIViewControllerRepresentable # We start with the simplest part: defining our structure.\nimport SwiftUI import MessageUI struct MailView: UIViewControllerRepresentable { typealias UIViewControllerType = MFMailComposeViewController } Since UIViewControllerRepresentable is a protocol with an associated type, we need to specify the type of our view.\nOnce done, we will have to implement the rest of the protocol:\nstruct MailView: UIViewControllerRepresentable { typealias UIViewControllerType = MFMailComposeViewController func makeUIViewController(context: Context) -\u0026gt; MFMailComposeViewController { } func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) { } } Note that it is not necessary to keep the following line as long as the makeUIViewController method is defined with the right return type:\ntypealias UIViewControllerType = MFMailComposeViewController We can therefore simplify our representation as follows:\nstruct MailView: UIViewControllerRepresentable { func makeUIViewController(context: Context) -\u0026gt; MFMailComposeViewController { } func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) { } } makeUIViewController # Let\u0026rsquo;s have a look at the two new methods that are available to us. The first one is makeUIViewController. It will allow us to create our ViewController, in this case our MFMailComposeViewController. It is therefore essential to implement it. By the way, at this time, your code should not compile.\nSo let\u0026rsquo;s start with this one.\nstruct MailView: UIViewControllerRepresentable { @Binding var data: ComposeMailData func makeUIViewController(context: Context) -\u0026gt; MFMailComposeViewController { let vc = MFMailComposeViewController() vc.setSubject(data.subject) vc.setToRecipients(data.recipients) vc.setMessageBody(data.message, isHTML: false) data.attachments?.forEach { vc.addAttachmentData($0.data, mimeType: $0.mimeType, fileName: $0.fileName) } vc.accessibilityElementDidLoseFocus() return vc } func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) { } } You will notice that I added a binded variable of type ComposeMailData which is strongly used for the construction of our ViewController :\nstruct ComposeMailData { let subject: String let recipients: [String]? let message: String let attachments: [AttachmentData]? } struct AttachmentData { let data: Data let mimeType: String let fileName: String } The goal is that we can, when creating our page, specify default values for the different fields. Very useful when we want to customize the page.\nLet\u0026rsquo;s continue with the second method.\nupdateUIViewController # The updateUIViewController method allows you to notify your view of changes made within SwiftUI. In our case, we won\u0026rsquo;t need it.\nAt this level of design, our ViewController is usable.\nCoordinator # You will notice that everything seems to work, except for one detail: It is impossible for us to know if the user has sent the email or not.\nLet\u0026rsquo;s fix this problem.\nThe updateUIViewController method allows you to notify your view of changes made in SwiftUI, but how to notify SwiftUI of a change in our view?\nBy default it is not possible.\nThe system doesn’t automatically communicate changes occurring within your view controller to other parts of your SwiftUI interface. When you want your view controller to coordinate with other SwiftUI views, you must provide a Coordinator instance to facilitate those interactions. For example, you use a coordinator to forward target-action and delegate messages from your view controller to any SwiftUI views.\nLet\u0026rsquo;s implement our coordinator to take care of that:\ntypealias MailViewCallback = ((Result\u0026lt;MFMailComposeResult, Error\u0026gt;) -\u0026gt; Void)? struct MailView: UIViewControllerRepresentable { @Environment(\\.presentationMode) var presentation @Binding var data: ComposeMailData class Coordinator: NSObject, MFMailComposeViewControllerDelegate { @Binding var presentation: PresentationMode @Binding var data: ComposeMailData let callback: MailViewCallback init(presentation: Binding\u0026lt;PresentationMode\u0026gt;, data: Binding\u0026lt;ComposeMailData\u0026gt;, callback: MailViewCallback) { _presentation = presentation _data = data self.callback = callback } func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { if let error = error { callback?(.failure(error)) } else { callback?(.success(result)) } $presentation.wrappedValue.dismiss() } } func makeCoordinator() -\u0026gt; Coordinator { Coordinator(presentation: presentation, data: $data, callback: callback) } func makeUIViewController(context: Context) -\u0026gt; MFMailComposeViewController { let vc = MFMailComposeViewController() vc.mailComposeDelegate = context.coordinator vc.setSubject(data.subject) vc.setToRecipients(data.recipients) vc.setMessageBody(data.message, isHTML: false) data.attachments?.forEach { vc.addAttachmentData($0.data, mimeType: $0.mimeType, fileName: $0.fileName) } vc.accessibilityElementDidLoseFocus() return vc } func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) { } } In the case of a user sending or cancelling, we have to leave the page and therefore notify the SwiftUI part of this change. So I added the variable environment to allow us to do a dismiss when the time comes:\n@Environment(\\.presentationMode) var presentation It is also important to see that our Coordinator implements the MFMailComposeViewControllerDelegate protocol:\nclass Coordinator: NSObject, MFMailComposeViewControllerDelegate We can now reference this delegate when creating our ViewController:\nvc.mailComposeDelegate = context.coordinator As for the callback, it is here to notify the viewModel or the calling view of the decision taken by the user.\nUsing our new view # We have just realized from scratch a SwiftUI view from a UIKit ViewController. Now we have to use it in our application.\nViewModel # First of all, let\u0026rsquo;s define in our ViewModel all the variables and methods necessary for the good execution of our view MailView.\nAs a reminder we need to give it 2 pieces of information:\nAn instance of the ComposeMailData structure with the values to use by default A callback to know if the user has sent or cancelled the mail final class TestViewModel: ObservableObject { @Published var isShowingMailView = false @Published var mailComposeData: ComposeMailData override init() { mailComposeData = ComposeMailData(subject: \u0026#34;\u0026#34;, recipients: [\u0026#34;myMail@mail.com\u0026#34;], message: \u0026#34;\u0026#34;, attachments: nil) } func contactMe() { isShowingMailView = true } func mail(result: Result\u0026lt;MFMailComposeResult, Error\u0026gt;) { // Nothing to do here yet } } View # Now we just need to add our new view and bind the different values:\nstruct TestView: View { var body: some View { NavigationView { List { ... } .navigationTitle(\u0026#34;Test\u0026#34;) } .sheet(isPresented: $viewModel.isShowingMailView) { MailView(data: $viewModel.mailComposeData, callback: viewModel.mail) } } } As you can see, it is quite easy to implement a UIKit ViewController in a SwiftUI application.\nSo now it\u0026rsquo;s up to you to get started!\n","date":"1 March 2022","permalink":"/blog/posts/uikit-view-on-swiftui/","section":"Posts","summary":"UIKit ViewController with SwiftUI # If you are curious like me, you must have tested SwiftUI. Personally I like this framework more and more. But I will tell you about my feedback in another article. However I have to reproach it for something: it still lacks a lot of things!\nAnd yes, SwiftUI tries to join all the worlds (iOS, macOS, \u0026hellip;) in one. The problem is that the task is not easy.","title":"UIKit ViewController with SwiftUI"},{"content":"Have you ever made an iOS app with UIKit? Have you ever made your own views? Customized a user control or a view?\nThen you have probably already been in contact with the frames and bounds. But how well do you know them? Do you really know the difference between the two?\nI noticed that for many the answer was: No.\nSo let\u0026rsquo;s go back to these notions to learn more.\nIf we look at the documentation of the two properties, we notice that their declaration is identical except for the name :\nFrame:\nvar frame: CGRect { get set } Bounds:\nvar bounds: CGRect { get set } Note that both properties return a structure of type CGRect. This one simply represents a rectangle in memory, that is to say 4 essential information: X, Y, width and height.\nBut then where is the difference?\nIf we look at the documentation of frame, it says this :\nThe frame rectangle, which describes the view’s location and size in its superview’s coordinate system.\nNote the importance of the end of the sentence: its superview\u0026rsquo;s coordinate system. This is not at all what is specified for the other property:\nThe bounds rectangle, which describes the view’s location and size in its own coordinate system.\nWhat does this mean in reality?\nIt\u0026rsquo;s quite simple really, the bounds will have the coordinates relative to itself and will therefore have an X and a Y always equal to 0. While the frame will take these coordinates relative to its parent in the view hierarchy.\nIt is therefore important to refer to the frame if you want to have the position of the view, the bounds does not know the hierarchy of the view.\nHowever, for the width and height, you can look at either one or the other. When one value is updated, the other is also updated.\n","date":"27 February 2022","permalink":"/blog/posts/frame-versus-bounds/","section":"Posts","summary":"Have you ever made an iOS app with UIKit? Have you ever made your own views? Customized a user control or a view?\nThen you have probably already been in contact with the frames and bounds. But how well do you know them? Do you really know the difference between the two?\nI noticed that for many the answer was: No.\nSo let\u0026rsquo;s go back to these notions to learn more.","title":"Swift: bounds vs frame"},{"content":" You may have already had it but there is a bug on UITextField only on iOS emulators (iPhone and iPad). It may happen that when you select a UITextField your application freezes like the picture below:\nNow that your application looks like this, you cannot do anything and you have to restart your application.\nvia GIPHY\nThis is a bug known by the Apple team and originally seemed to affect only the iOS 13 version. But I can confirm that I also encountered it on emulators with version 14.\nBut I reassure you, nothing comes from your code but from the emulator itself. So even if you are not anative developer, you may encounter this problem, as here for NativeScript :\n![https://github.com/NativeScript/NativeScript/issues/7919#issue-504001839]\nBut then how to solve it?\nWell, it\u0026rsquo;s very simple! Just restart your emulator.I hope this helped you and that unlike me, you won\u0026rsquo;t spend 2 hours looking for a solution in your code.\n","date":"4 January 2022","permalink":"/blog/posts/uitextfield-bug/","section":"Posts","summary":"You may have already had it but there is a bug on UITextField only on iOS emulators (iPhone and iPad). It may happen that when you select a UITextField your application freezes like the picture below:\nNow that your application looks like this, you cannot do anything and you have to restart your application.\nvia GIPHY\nThis is a bug known by the Apple team and originally seemed to affect only the iOS 13 version.","title":"UITextField bug 😱"},{"content":" What is a file attribute? # I will probably push an open door, but a file system has attributes on the files. In particular, the read, write and execute of each file and this for the different groups:\n-rw-rw-r-- 1 kelvas users 5120 Jul 09 04:30 sample.txt But these attributes were not enough for many cases. So an extension was added to the inodes to allow more functionality on the files: the extended attributes or xattr.\nHow it works # Unlike regular attributes, extended attributes are not interpreted by the file system, but are stored and managed separately. Any extended attribute is identified by a pair (name:value) that allows manipulation of the stored information.\nSome file systems require special mount options to enable support for extended attributes.\nLinux and macOS # Many Linux distributions include the extended attributes and also macOS since version 10.4 thanks to the HFS+ file system.\nOkay, but why? # You\u0026rsquo;re going to say to me, \u0026ldquo;Why are you talking about this today?\u0026rdquo;. Well, it\u0026rsquo;s quite simple. You know I like to code and I like to share. Well recently I had to share a macOS application with a friend and he could never open the application because of this error:\nStrange because I tested the application just before sending it and everything worked perfectly. Of course, my first reflex was to make him re-download the ZIP containing the application: without success. My second reflex was to question my ZIP and to change for a TAR or a GZIP: no change yet.\nAnd it\u0026rsquo;s after several research that I discovered these famous xattr.Once downloaded and unzipped, the application had the following attributes:\ncom.apple.quarantine: 0083;61b9bd2d;Safari;7E8E7E48-6187-4915-BF12-2FF346BF1306 As the application was not downloaded from the store, it was automatically quarantined by the system, which of course prevents the execution of the software even though the \u0026ldquo;standard\u0026rdquo; attribute of execution is valid for the user and his group.\nTo see the list of extended attributes, you will need this command:\nxattr -l path/to/myFile.ext And if you need to remove all extended attributes from a file, this command will be very useful:\nxattr -cr path/to/myFile.ext In my case removing the quarantine, attribute allowed me to launch the application. Of course, I invite you to be careful with the management of these attributes that are used by the system and the applications to work properly.\n","date":"2 January 2022","permalink":"/blog/posts/macos-xattr-attributes/","section":"Posts","summary":"What is a file attribute? # I will probably push an open door, but a file system has attributes on the files. In particular, the read, write and execute of each file and this for the different groups:\n-rw-rw-r-- 1 kelvas users 5120 Jul 09 04:30 sample.txt But these attributes were not enough for many cases. So an extension was added to the inodes to allow more functionality on the files: the extended attributes or xattr.","title":"macOS xattr attributes"},{"content":" The pillars of the software (1/2) # Today we will leave the mobile topics and talk about the thousands of software. What I mean here by pillar is the software / libraries that everyone uses directly or indirectly (via other software / libraries). And we will see together that a lot relies on little and that is a bit scary!\nActually I wanted to talk about this because I came across this tweet from Mike van Riel (@mvriel: https://twitter.com/mvriel) a fellow developer who posted this:\nI think you agree with me, it\u0026rsquo;s sobering. And it\u0026rsquo;s true that I had never thought about it before! So I got interested in the subject and wanted to share with you what I discovered!\ncURL # Let\u0026rsquo;s start with the one we all used at least once, the one we see everywhere in API examples, the one we are taught in school: cURL.\nIt was created in 1998 by Daniel Stenberg (https://en.wikipedia.org/wiki/Daniel_Stenberg) and if you don\u0026rsquo;t know, cURL stands for \u0026ldquo;Client URL\u0026rdquo;.\nIt is available on GitHub at this address: https://github.com/curl/curl\nIt allows to transfer data through a multitude of protocols: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. curl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, HTTP/3, \u0026hellip;\nAnd according to their site, cURL is also used in cars, TVs, routers, printers, audio equipment, cell phones, tablets, set-top boxes, media players and is the Internet transfer engine for thousands of software applications in over ten billion installations.\nIf I were the creator of this marvel I would be really proud of the success of my software. Because yes, when we reach more than 10 billion installations, I think we can easily talk about success!\nHere is the official website of the software: https://curl.se/\nBut who maintains the software?\nIf we believe GitHub and the contributors page they are, at the time of writing, 729 contributors. But this count includes all contributors: from those who added a feature to those who corrected a spelling mistake in a comment to those who fixed security holes.\nSo let\u0026rsquo;s take a look at the top contributors.\nAs you can see, we fall very quickly below the thousand of commits per developer and that therefore, we have mainly 3 main developers on the subject! The first is badger the creator of cURL, which seems logical.\nThe second one is yangtse and his profile does not include any information. So let\u0026rsquo;s consider that he is a person interested but not necessarily related to cURL.\nAnd the third one is Steve Holme who works for cURL if we believe his GitHub profile.\nSo we can see that indeed, despite the strong use and popularity of the software, there is almost nobody on the subject. Everything rests on the shoulders of 3 people.\nWhich, let\u0026rsquo;s face it, can be scary! Imagine that tomorrow they decide to retire, or that they are no longer passionate about this project. What will happen? So I know that the open source community is supposed to take over, but we all know that taking over someone else\u0026rsquo;s development is always complicated. Especially when the project has been around for so long.\nSo as Mike van Riel said, cURL doesn\u0026rsquo;t rely on many people and yet it\u0026rsquo;s one of the most used software/libraries in the world!\nIt makes you think!\n","date":"15 July 2021","permalink":"/blog/posts/pillars-software-1-on-2/","section":"Posts","summary":"The pillars of the software (1/2) # Today we will leave the mobile topics and talk about the thousands of software. What I mean here by pillar is the software / libraries that everyone uses directly or indirectly (via other software / libraries). And we will see together that a lot relies on little and that is a bit scary!\nActually I wanted to talk about this because I came across this tweet from Mike van Riel (@mvriel: https://twitter.","title":"The pillars of the software (1/2)"},{"content":" Segmentation fault and .NET on Linux # For some time I have re-enabled one of my PC with a good Linux Manjaro, it\u0026rsquo;s very convenient to run tens of services continuously without having to leave my Mac on or at home.\nAnd I wanted to experience .NET development with VSCode (to do Blazor I admit it) all on my Linux.\nOf course I follow the Microsoft tutorials to set up the environment and I start here: https://docs.microsoft.com/en-us/dotnet/core/install/linux-snap\nWhen I get to the \u0026ldquo;Install SDK\u0026rdquo; step, we are asked to use this command:\nsudo snap install dotnet-sdk --classic --channel=5.0 Nothing more normal on my Linux (well from my short experience), we use the snap utility to download, install and manage the .NET SDK. I continue with the runtime. So far so good. I end up installing VSCode, still from snap.\nAnd finally comes the long awaited moment to start a new project. As I use VSCode and not Visual Studio it is necessary to create the projects via command line and not via the graphical interface :\ndotnet new blazorserver -o BlazorApp --no-https And then it\u0026rsquo;s drama! 😭 :\nSegmentation fault (core dumped) Impossible to create projects. The tool crashes no matter what type of project I want to create. So I start looking for a solution on the Internet. After several ten minutes of research I end up on this link: https://github.com/dotnet/sdk/issues/11639\nThey talk about the DOTNET_CLI_TELEMETRY_OPTOUT variable which is the cause of the problem. After an attempt on my side the behavior persists. No solution seems to work until I see the comment of Wowo10 :\nAnd there to the miracle it works! 🎉\nHere are the commands if you need them:\nsudo snap remove dotnet-sdk sudo pacman -S dotnet-sdk Other comments suggest that downloading .NET via pacman and apt-get works but not via snap. So if you also have the problem, I invite you to use these commands to get your .NET SDK working properly.\nWhat is quite strange is that nothing is specified on the Microsoft website and that it seems to come from Snap. However, the problem seems to be present since 2019 even if the ticket is closed only since yesterday. Maybe we\u0026rsquo;ll get to the bottom of this one day.\nUntil then, have fun with .NET on Linux!\n","date":"4 July 2021","permalink":"/blog/posts/segmentation-fault-dotnet-linux/","section":"Posts","summary":"Segmentation fault and .NET on Linux # For some time I have re-enabled one of my PC with a good Linux Manjaro, it\u0026rsquo;s very convenient to run tens of services continuously without having to leave my Mac on or at home.\nAnd I wanted to experience .NET development with VSCode (to do Blazor I admit it) all on my Linux.\nOf course I follow the Microsoft tutorials to set up the environment and I start here: https://docs.","title":"Segmentation fault and .NET on Linux"},{"content":" As you\u0026rsquo;ve probably gathered from the previous articles, I mostly do iOS and Android mobile. But from time to time, I go outside this mobile bubble to do other things.\nThe interesting thing about doing Xamarin for mobile is that it\u0026rsquo;s easy to port our application to desktop environments. But when I left my iOS and Android cocoon, I quickly realized that the tools for desktop development were not necessarily as advanced as their smartphone brother.\nAnd finally: especially on MacOS!\nThe problem # From time to time during the development of one of my applications, I found myself with crashes of this one without stacktrace or exception that .NET had accustomed me to until now. But only a good old dump like this one :\n================================================================= Native Crash Reporting ================================================================= Got a abrt while executing native code. This usually indicates a fatal error in the mono runtime or one of the native libraries used by your application. ================================================================= ================================================================= Native stacktrace: ================================================================= 0x1041d28a6 - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_dump_native_crash_info 0x1041c647e - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_handle_native_crash 0x1041d1eaf - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : sigabrt_signal_handler 0x7fff2039fd7d - /usr/lib/system/libsystem_platform.dylib : _sigtramp 0x7fff20326133 - /usr/lib/system/libsystem_kernel.dylib : host_create_mach_voucher 0x7fff20348fef - /usr/lib/system/libsystem_kernel.dylib : __darwin_check_fd_set_overflow.cold.1 0x7fff24b010ae - /System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC : __TCCAccessRequest_block_invoke_2 0x7fff24b018df - /System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC : __TCCAccessRequest_block_invoke.138 0x7fff24aff504 - /System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC : __tccd_send_message_block_invoke 0x7fff200a1a9c - /usr/lib/system/libxpc.dylib : _xpc_connection_reply_callout 0x7fff200a1a24 - /usr/lib/system/libxpc.dylib : _xpc_connection_call_reply_async 0x7fff201b0870 - /usr/lib/system/libdispatch.dylib : _dispatch_client_callout3 0x7fff201c9035 - /usr/lib/system/libdispatch.dylib : _dispatch_mach_msg_async_reply_invoke 0x7fff201c051c - /usr/lib/system/libdispatch.dylib : _dispatch_kevent_worker_thread 0x7fff203574a5 - /usr/lib/system/libsystem_pthread.dylib : _pthread_wqthread 0x7fff2035642f - /usr/lib/system/libsystem_pthread.dylib : start_wqthread ================================================================= Telemetry Dumper: ================================================================= Thread 0x30d034000 may have been prematurely finalized* Assertion at /Users/builder/jenkins/workspace/archive-mono/2020-02/mac/release/mono/utils/mono-threads.c:650, condition `info\u0026#39; not met, function:mono_thread_info_current, I might as well tell you that when you read lines like :\n0x1041d28a6 - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_dump_native_crash_info 0x1041c647e - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_handle_native_crash 0x1041d1eaf - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : sigabrt_signal_handler We are not very serene on the way to solve this. We find ourselves without any concrete clue and we end up doing what my grandfather used to do: put print(\u0026ldquo;Foo\u0026rdquo;) everywhere to know where the code stops.\nBeyond the fact that this technique is very annoying, it is also doomed to failure as soon as you manage several Threads and/or your application makes several hundreds/thousands lines of code with hundreds of different classes.\nPossible solutions # AOT # According to Chris Hamons (https://github.com/chamons), one of the main contributors to Xamarin.Mac, you can enable Ahead Of Time compilation on your project to get a better stacktrace and therefore potentially more research and reflection on your problem.\nAOT compilation is a compilation that translates a high-level language into machine language before the execution of a program, as opposed to just-in-time compilation, which is done at runtime.\nPre-compilation allows you to have a global view of the code, which is not the case with on-the-fly compilation, which can only make local optimizations. Early compilation allows to reduce the costs of exception handling and calls to methods and interfaces.\nUnfortunately this technique is not always possible. In my personal case I use the SQLite library which prevents the passage in AOT.\nMoreover, it is to be noted that this technique is to be applied only in debug, since the produced code is more voluminous and less fast. So remember to disable it before compiling in release.\nThe console # You may know it but the \u0026ldquo;Console\u0026rdquo; program on MacOS allows you to see everything that is happening on your machine. It is the equivalent of \u0026ldquo;Event Viewer\u0026rdquo; on Windows or \u0026ldquo;Logcat\u0026rdquo; on Android.\nFor some problems, it is my best friend. Being system specific and not linked to your application, it is able to log more information about crashes than your own application with its logger.\nMoreover, belonging to the system, it has a different point of view. It will give you additional information about what the system is doing with your application: adding an event, deleting an event, system warning, certificate problem, \u0026hellip;\nHow to use the console to debug? # You will see, it is quite simple, not to say childish. First of all, open the Console application. Your application must always be turned off.\nThen activate the log capture with the central button:\nYou will now see a large amount of logs appearing on your screen. These concern the whole system and all applications. No question of sorting out all this ourselves.\nIn the search bar type the name of your application or its bundle id. You will see that normally all the logs will disappear to leave a blank page.\nNow launch your application in debug and try to reproduce your crash.\nThe logs will start to appear. Of course, all the logs do not necessarily represent an error. It is all the information that the system sees fit to expose.\nOnce your crash has been reproduced, go to the console and look at the last logs present in the console, they will surely help you! In my case, for example, it was a lack of permission in the Info.plist. And I was able to find this out thanks to this line:\nRefusing authorization request for service kTCCServiceBluetoothAlways and subject Sub:{com.kevinsibue.myapp}Resp:{identifier=\u0026lt;ID of InvalidCode\u0026gt;, pid=11337, auid=501, euid=501, binary_path=/Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp} without NSBluetoothAlwaysUsageDescription key So we are far from the original dump that made me want to tear my hair out. And at least here the error is clear! Our application is killed because it doesn\u0026rsquo;t have in the Info.plist the NSBluetoothAlwaysUsageDescription key. I just have to add it to make the error disappear.\nCrashes # In general, if your application crashes, we are never sure to have the information in the application logs.\nThe method we have seen before is interesting but requires to open the console before using the application. And clearly your customers won\u0026rsquo;t do it and maybe your testers won\u0026rsquo;t either.\nThe first solution would be to set up a bug reporter like AppCenter or Firebase Crashlytics. They work very well for mobile. But no such luck for Xamarin.Mac applications.\nFortunately, it is possible to access the crash log directly on your Mac.\nStill in the Console application, and you will be in the left sidebar, subsection \u0026ldquo;Report\u0026rdquo; the item \u0026ldquo;Blocking report\u0026rdquo;. This one will contain all the crash logs recorded by the system for your application!\nProcess: MyApp [11218] Path: /Users/USER/Documents/*/MyApp.app/Contents/MacOS/MyApp Identifier: com.kevinsibue.myapp Version: 48.8 (1) Code Type: X86-64 (Translated) Parent Process: ??? [1] Responsible: MyApp [11218] User ID: 501 Date/Time: 2021-06-12 16:16:10.842 +0200 OS Version: macOS 11.4 (20F71) Report Version: 12 Anonymous UUID: ACE4D874-1610-4A86-D6EE-681EE74AD581 Sleep/Wake UUID: E83C9115-81A1-4AF3-91E2-BE359E9F4A2B Time Awake Since Boot: 28000 seconds Time Since Wake: 460 seconds System Integrity Protection: enabled Crashed Thread: 7 Thread Pool Worker Exception Type: EXC_BAD_ACCESS (SIGABRT) Exception Codes: KERN_INVALID_ADDRESS at 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY VM Regions Near 0: --\u0026gt; __TEXT 104738000-104cd0000 [ 5728K] r-x/r-x SM=COW /Users/*/Documents/*/MyApp.app/Contents/MacOS/MyApp Application Specific Information: abort() called Thread 0:: tid_103 Dispatch queue: com.apple.main-thread 0 ??? 0x00007ffe94316ab8 ??? 1 libsystem_kernel.dylib 0x00007fff203252ba mach_msg_trap + 10 2 com.apple.CoreFoundation 0x00007fff204538c5 __CFRunLoopServiceMachPort + 316 3 com.apple.CoreFoundation 0x00007fff20451f7b __CFRunLoopRun + 1332 4 com.apple.CoreFoundation 0x00007fff20451380 CFRunLoopRunSpecific + 567 5 com.apple.HIToolbox 0x00007fff288f1ab3 RunCurrentEventLoopInMode + 292 6 com.apple.HIToolbox 0x00007fff288f1815 ReceiveNextEventCommon + 587 7 com.apple.HIToolbox 0x00007fff288f15b3 _BlockUntilNextEventMatchingListInModeWithFilter + 70 8 com.apple.AppKit 0x00007fff22b7c6f2 _DPSNextEvent + 864 9 com.apple.AppKit 0x00007fff22b7aec5 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1364 10 com.apple.AppKit 0x00007fff22b6d239 -[NSApplication run] + 586 11 com.apple.AppKit 0x00007fff22b4147c NSApplicationMain + 816 12 ??? 0x0000000118183147 ??? 13 ??? 0x0000000118182df3 ??? 14 ??? 0x0000000110fd97fb ??? 15 ??? 0x0000000110fd9971 ??? 16 com.kevinsibue.myapp 0x00000001048631ce mono_jit_runtime_invoke + 1550 (mini-runtime.c:3191) 17 com.kevinsibue.myapp 0x00000001049982d8 do_runtime_invoke + 54 (object.c:3052) [inlined] 18 com.kevinsibue.myapp 0x00000001049982d8 mono_runtime_invoke_checked + 136 (object.c:3220) 19 com.kevinsibue.myapp 0x000000010499f605 do_exec_main_checked + 60 [inlined] 20 com.kevinsibue.myapp 0x000000010499f605 mono_runtime_exec_main_checked + 117 (object.c:5284) 21 com.kevinsibue.myapp 0x00000001047bf59c mono_jit_exec_internal + 14 (driver.c:1383) [inlined] 22 com.kevinsibue.myapp 0x00000001047bf59c mono_jit_exec + 364 (driver.c:1328) 23 com.kevinsibue.myapp 0x00000001047c2696 main_thread_handler + 71 (driver.c:1465) [inlined] 24 com.kevinsibue.myapp 0x00000001047c2696 mono_main + 8790 (driver.c:2714) 25 com.kevinsibue.myapp 0x00000001047775bc xamarin_main + 1116 (launcher.m:656) 26 com.kevinsibue.myapp 0x0000000104778434 main + 36 (launcher.m:675) 27 libdyld.dylib 0x00007fff20375f5d start + 1 And these logs are available even without activating the console before a test. Quite practical!\nThere is already a very good article from Microsoft on the subject: https://docs.microsoft.com/fr-fr/xamarin/mac/deploy-test/debugging-native-crash. I invite you to read it to better manage these error cases.\n","date":"12 June 2021","permalink":"/blog/posts/incomprehensible-errors/","section":"Posts","summary":"As you\u0026rsquo;ve probably gathered from the previous articles, I mostly do iOS and Android mobile. But from time to time, I go outside this mobile bubble to do other things.\nThe interesting thing about doing Xamarin for mobile is that it\u0026rsquo;s easy to port our application to desktop environments. But when I left my iOS and Android cocoon, I quickly realized that the tools for desktop development were not necessarily as advanced as their smartphone brother.","title":"Incomprehensible errors"},{"content":" If you like to share and you make code, you probably have a GitHub, GitLab or other account to share your interesting pieces of code to the world.\nLike any Git repo, you\u0026rsquo;re going to have a README file. And you may not know it yet, but this is perhaps the most important part of your repo.\nBeyond your code and its quality, when you share code, it is important that developers who find your code can easily understand what it is about and especially to give them confidence in you, even if they have never seen you before and do not (yet) know your work.\nWhat are the important points to address then?\nDependencies # Most, if not all, mobile applications have dependencies on other frameworks or libraries. It is important to take them into account for your README, since they may induce limitations or links not desired by the developer using your code.\nThe platform and the framework # Let\u0026rsquo;s start with the most obvious and the one that is mandatory in all cases: platforms and framework.\nLet\u0026rsquo;s take the case of the construction of a Swift Package. This one will contain Swift code created by you in order to facilitate the use of TableViews for example. Therefore your code is directly dependent on UIKit containing the UITableView.\nTherefore, your Swift code which until now was universal is only available if UIKit is also universal and therefore on iOS and iPadOS.\nIt is therefore essential that you indicate in your README three points: UIKit, iOS and iPadOS. These dependencies may prevent another developer from using your code, so you must inform him very quickly to avoid any confusion or problem.\nThird-party dependencies # As well as the platform or system framework used, it is possible that you use a third party dependency. It is also necessary to specify this dependency for several reasons.\nThe application that will use your code may already use the same dependency but in another version, which can cause problems.\nBut even worse, the third party dependency have no guarantee of long term support. It is the creator with his community (if it exists) that maintains the existing code. This means that maybe, one day, nobody will be there to fix the bugs or make the necessary evolutions to support the new versions of the system.\nIt is therefore essential to properly specify these high-risk dependencies.\nThe tests # But how to give confidence to other developers? It\u0026rsquo;s very simple: the quality of your code. And the best way I know for that is simply unit tests!\nThey are essential to justify the use of your code. They allow anyone to be sure that you have done your work well. In addition, the analysis of unit tests allows you to quickly realize the quality of work and the way a developer works.\nThey are even more important when the developer\u0026rsquo;s goal is not to integrate your code but to fork it to make another version.\nAdd to this the code coverage and you have 2 strong arguments to easily allow the adoption of your code!\nThe people who trust us # Let\u0026rsquo;s not forget that few things have not already been done. So why take your solution rather than the neighbor\u0026rsquo;s?\nThe previous chapters are good reasons, but there is even better: the companies / communities / applications that use your code.\nIf you have companies like Uber or AirBnb embedding your code in their mobile app, it can only help you gain credibility.\nSo don\u0026rsquo;t forget to list those actors who believe in you!\nThe license # The license of your code is crucial for any developer who would like to use your code. Don\u0026rsquo;t forget that some of you will want to integrate it in your own code to share, others in their personal application and finally companies may need it for products they want to sell.\nIt\u0026rsquo;s up to you to specify the right license. If you are on GitHub, you can directly choose a license when creating your Git repo. This will create a LICENSE.md file at the root of your repo.\nHere is a reminder of the most used licenses:\nIf you have trouble choosing the most suitable license for your situation, here is a very good site with all the information you need: https://choosealicense.com/licenses/\nBadges # We have seen a lot of points that are important. But there is still one that, despite the little space it takes in your readme, I think is crucial: the badges.\nThey don\u0026rsquo;t take up space, they are simple and sober but allow a clear and simple message to be conveyed to everyone.\nI recommend to put them at the beginning of your README so that they serve as a summary of your repo. Developers will be grateful to you for this since they allow you not to linger too long on a repo that is not suitable.\nIf you want to know more about badges and how to generate them, I invite you to go to this site: https://shields.io/\nOverall body # Here is the body of your README in a nutshell:\nTitle and image Badges (build, unit tests, code coverage, platforms, \u0026hellip;) Current version Requirements Features Installation Getting Started Change logs Contribute License Of course this may change depending on the type of code you share. The \u0026ldquo;Installation\u0026rdquo; section is very useful when you share a Swift Package or a Cocoapods but not at all for a sample code.\nGood examples in my opinion # Rather than continuing to list the things that need to be addressed, let\u0026rsquo;s look at what others are doing that I think is right:\nhttps://github.com/firebase/firebase-ios-sdk https://github.com/ReactiveX/RxSwift https://github.com/stripe/stripe-ios I hope this article will have more for you! Do not hesitate to share it and leave a comment!\n","date":"5 June 2021","permalink":"/blog/posts/how-make-good-readme/","section":"Posts","summary":"If you like to share and you make code, you probably have a GitHub, GitLab or other account to share your interesting pieces of code to the world.\nLike any Git repo, you\u0026rsquo;re going to have a README file. And you may not know it yet, but this is perhaps the most important part of your repo.\nBeyond your code and its quality, when you share code, it is important that developers who find your code can easily understand what it is about and especially to give them confidence in you, even if they have never seen you before and do not (yet) know your work.","title":"How to make a good README?"},{"content":" In software development there is one thing that is difficult to achieve : quality.\nAnyone can code but few are able to code good software. When I say good I mean robust, stable and malleable according to the necessary evolutions.\nBut to guarantee such a quality you need tools. Beyond the timeless design pattern, debugging tools or other, there are especially unit tests.\nOf course making an iOS application in Swift is no exception to the rule. But as with any language there is always something quite complicated to test, namely asynchronism.\nIf you don\u0026rsquo;t have the answer to this question yet and you are a beginner in unit testing or Swift, then I invite you to read the rest of this article.\nLike any self-respecting program in iOS, we parallelise a maximum number of tasks. To do this, we need to use DispatchQueues which themselves generate callbacks or completionBlock. This only promises us that we will return to this place in the code at a given moment, but when?\nOn the other hand, a unit test is much simpler. It is just a function that runs synchronously.\nSo how to combine synchronous and asynchronous?\nIf like me you are used to C# nothing could be simpler. You just have to put the keyword async and return a Task type for everything to work. Unfortunately for us and for the moment before Swift 5.5 we have to work with callbacks.\n[TestMethod] public async Task SumTest_WhenInput1And2_Returns3() { var sum = await math.GetSumAsync(1, 2); sum.Should().Be(3) } In Swift, it will be necessary to wait for the end of the execution of our callback. But how to do this? How to play with time?\nWe all know a simple method to make code wait for a certain or infinite time until something asynchronous ends: a semaphore or a mutex.\nBut Apple has already provided for us and everything we need with the Expectation class.\nThis allows you to define a given time before the mutex is automatically released or the callback arrives.\nfinal class KVFaqResourceLoaderTests: XCTestCase { func test_load_validResource_Ok() throws { let expectation = XCTestExpectation(description: \u0026#34;Load local resource\u0026#34;) let resourceLoader = try KVFaqResourceLoader( bundleExplorer: KVFoundationBundleExplorer(), bundle: Bundle.module, resourceNameWithExtension: \u0026#34;faq.json\u0026#34; ) var loadData: Data? = nil var loadError: Error? = nil resourceLoader.load { (data, error) in loadData = data loadError = error expectation.fulfill() } wait(for: [expectation], timeout: 10.0) XCTAssertNotNil(loadData) XCTAssertNil(loadError) } } Nothing very complicated here. It is also possible to use the same Expectation several times for several callbacks.\nThe time here is important because it prevents your test from ever ending. This way we expect the task to last only a few seconds before it has to stop. In case the expectation stops because of the timeout your test will fail.\nI hope you enjoyed this article, don\u0026rsquo;t hesitate to share it or comment it. See you soon for more articles on mobility.\n","date":"31 May 2021","permalink":"/blog/posts/swift-async-unit-test/","section":"Posts","summary":"In software development there is one thing that is difficult to achieve : quality.\nAnyone can code but few are able to code good software. When I say good I mean robust, stable and malleable according to the necessary evolutions.\nBut to guarantee such a quality you need tools. Beyond the timeless design pattern, debugging tools or other, there are especially unit tests.\nOf course making an iOS application in Swift is no exception to the rule.","title":"Swift : Async unit tests"},{"content":" Kotlin Cache Management # In computer science, we always say that there are two things that are complicated: naming variables and managing the cache! And that\u0026rsquo;s absolutely true. Unfortunately, this is a recurring problem in mobility since we must save as much as possible the network consumption of the mobile device we have in our hands:\nnetwork loss weak networks (Edge, 3G,\u0026hellip;) \u0026hellip; It is therefore important to know how to manage data caching in order to provide a meaningful user experience. But again, it will depend on the data:\nIf you manage more or less static data, such as the product catalogue of a major car brand, there is no need to refresh the data from the server every 10 seconds or at each user\u0026rsquo;s request. We can afford to load them only once and keep them as long as the application is alive the data loaded upstream.\nOf course there are also cases where, as in a purchasing application, some data must constantly be reloaded and the cache is not very efficient.\nSo first, we will focus on our first case and see how it is possible to set up a cache on a REST request in Kotlin.\nFirst of all, some dependencies need to be resolved. To develop this small demo application, we will need:\nandroidx.appcompat:appcompat:1.0.2 androidx.core:core-ktx:1.0.2 androidx.constraintlayout:constraintlayout:1.1.3 com.squareup.retrofit2:retrofit:2.5.0 com.squareup.retrofit2:converter-gson:2.5.0 com.squareup.retrofit2:adapter-rxjava:2.5.0 com.squareup.okhttp3:logging-interceptor:3.12.1 io.reactivex.rxjava2:rxandroid:2.1.1 io.reactivex.rxjava2:rxkotlin:2.3.0 com.squareup.retrofit2:adapter-rxjava2:2.4.0 com.squareup.picasso:picasso:2.71828 androidx.legacy:legacy-support-v4:1.0.0 androidx.recyclerview:recyclerview:1.0.0 android.arch.lifecycle:extensions:1.1.1 androidx.cardview:cardview:1.0.0 jp.wasabeef:picasso-transformations:2.2.1 jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1 com.google.android.material:material:1.0.0 Don\u0026rsquo;t forget to synchronize your project via gradle after adding these dependencies. For this demo, we will use Rick and Morty\u0026rsquo;s free and open API : https://rickandmortyapi.com/\nFirst, we will display in a list the characters of Rick and Morty but without managing the pagination. The goal being to obtain something similar to this:\nNothing complicated so far. I won\u0026rsquo;t detail how to get to that but only on how to manage the cache. If the rest interests you, do not hesitate to consult the Git of this article.\nTo handle all this we\u0026rsquo;re going to need one of an ApiManager managing requests to the API:\nprivate const val API_BASE_URL = \u0026#34;https://rickandmortyapi.com/\u0026#34; class ApiManager { private val service: ApiService interface ApiService { @GET(\u0026#34;api/character\u0026#34;) fun retrieveCharacters(): Single\u0026lt;CharacterResult\u0026gt; @GET(\u0026#34;/api/character/{charactId}\u0026#34;) fun retrieveDetailCharactere(@Path(\u0026#34;charactId\u0026#34;) url: String): Single\u0026lt;Character\u0026gt; } init { service = Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client( OkHttpClient().newBuilder().addInterceptor(HttpLoggingInterceptor().apply { HttpLoggingInterceptor.Level.BASIC }) .build() ).build() .create(ApiService::class.java) } fun retrieveCharacters() = service.retrieveCharacters() fun retrieveDetailCharacter(url: String) = service.retrieveDetailCharactere(url) } As you can see, we will use Retrofit (lien YYYY) to manage API calls with an Rx adapter to manage observables.\nNevertheless, all intelligence will pass through the repository: CharactersRepository and CharactersCacheRepository. You have understood it one is for API calls as for the other, it takes care of loading the data from the cache i.e. RAM in our case.\nWe will therefore need an interface to transparently manage the two repositories :\ninterface ICharacterRepository { fun getCharacters(): Single\u0026lt;CharacterResult\u0026gt; fun getCharacterById(id: Long): Single\u0026lt;Character\u0026gt; } So we can now create our two classes:\nclass CharacterRepository(private val apiManager: ApiManager): ICharacterRepository { } class CharacterCacheRepository( private val delegate: CharacterRepository, private val characterResCache: ICharacterResultCache ): ICharacterRepository by delegate { } You will notice the presence of a new ICharacterCacheResult interface. But we\u0026rsquo;ll talk about it later.\nAs you can see, the principle is the same: We implement the interface. However, there will be 2 big changes:\nThe repository managing the cache has no direct link with the ApiManager and we use the keyword \u0026ldquo;delegate\u0026rdquo; for it. But what does this mean?\nAccording to the documentation available on Kotlang:\nThe Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. A class Derived can implement an interface Base by delegating all of its public members to a specified object\nThe goal is to have a repository that uses another one and not to have 2 repositories with logic everywhere in our code.\nSince each repository manages a particular data, it is possible to define different cache rules depending on the said data as we have seen previously!\nBut since both repositories use the same interface, it\u0026rsquo;s totally transparent for the rest of our code! In this case it is the repository managing the cache that will always be used. So we reverse the logic: rather than knowing if we are using the cache. By default we use this one and worry about when to use the network. It is therefore up to him to know whether or not to use the network depending on the cache he has and the management rules we want to put in place.\nLet\u0026rsquo;s now place directly in the application the instance of our CharacterCacheRepository which will take care of everything:\nlateinit var characterRepository: ICharacterRepository override fun onCreate() { super.onCreate() app = this initInjection() } private fun initInjection() { characterRepository = CharacterCacheRepository( CharacterRepository(ApiManager()), CharacterResultCache() ) } Don\u0026rsquo;t forget to link your android application to this class.\n\u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:roundIcon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/AppTheme\u0026#34; android:name=\u0026#34;.presentation.RMApplication\u0026#34;\u0026gt; ... \u0026lt;/application\u0026gt; It\u0026rsquo;s time to implement our repository and we\u0026rsquo;ll start with the simplest and the one we all know CharacterRepository:\nclass CharacterRepository(private val apiManager: ApiManager): ICharacterRepository { override fun getCharacters(): Single\u0026lt;CharacterResult\u0026gt; = apiManager.retrieveCharacters() override fun getCharacterById(id: Long): Single\u0026lt;Character\u0026gt; = apiManager.retrieveDetailCharacter(\u0026#34;$id\u0026#34;) } Nothing complicated here, we just use our ApiManager to do the job. No transformation required in this case.\nDo you remember the ICharacterCacheResult interface? It\u0026rsquo;s time to take care of it. In fact we will implement a class with this interface and it is it that will handle the management of cached data.\nclass CharacterResultCache: ICharacterResultCache { var mResult: CharacterResult? = null override val hasCharacters: Boolean get() = mResult != null override fun getResult(): CharacterResult? { return mResult } override fun getCharacter(id: Long): Maybe\u0026lt;Character\u0026gt; { mResult?.let { val found = it.results.filter { if (it.id == id) { return Maybe.just(it) } return Maybe.empty() }.first() return Maybe.just(found) } return Maybe.empty() } override fun getCharacters(): List\u0026lt;Character\u0026gt; { mResult?.let { return it.results } return emptyList() } override fun setResult(res: CharacterResult) { mResult = res } } We simply need to retrieve the list of characters or a particular character. To do this, simply analyze the result and save the result of the Http query.\nNow let\u0026rsquo;s do the simple version of our cache: If I have cache I send it back otherwise I make a request, I store the result and I return the result. As a result, at the next request there will be cache and there will be no need to make a new request to the server.\nclass CharacterCacheRepository( private val delegate: CharacterRepository, private val characterResCache: ICharacterResultCache ): ICharacterRepository by delegate { override fun getCharacters(): Single\u0026lt;CharacterResult\u0026gt; { if (characterResCache.hasCharacters) { return Single.create { emitter -\u0026gt; characterResCache.getResult()?.let { emitter.onSuccess(it) } } } else { return delegate.getCharacters().doOnSuccess { characters -\u0026gt; characterResCache.setResult(characters) } } } override fun getCharacterById(id: Long): Single\u0026lt;Character\u0026gt; { return characterResCache.getCharacter(id) .switchIfEmpty(delegate.getCharacterById(id)) } } All we have to do now is implement the apple in the repository in the viewModel of our page:\nclass CharactersViewModel : BaseViewModel() { var mItems: MutableLiveData\u0026lt;MutableList\u0026lt;Character\u0026gt;\u0026gt; = MutableLiveData() private var onSubscribe: Disposable? = null @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun onResume() { loadData() } override fun onCleared() { onSubscribe?.dispose() super.onCleared() } fun loadData() { mIsLoading.value = true val characterResult: Single\u0026lt;CharacterResult\u0026gt; = RMApplication.app.characterRepository.getCharacters() onSubscribe = characterResult .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribeBy( onSuccess = { mIsLoading.postValue(false) mItems.postValue(it.results.toMutableList()) }, onError = { mError.postValue(it) } ) } } There you go! You have a cache, some simple, but fully functional! Now it\u0026rsquo;s up to you to add new conditions to manage the cache of your application.\nIf you want to see the full code of this application, feel free to visit my git.\nIf you wish to discuss the subject, do not hesitate to contact me with a comment ;)\n","date":"19 April 2021","permalink":"/blog/posts/kotlin-cache-management/","section":"Posts","summary":"Kotlin Cache Management # In computer science, we always say that there are two things that are complicated: naming variables and managing the cache! And that\u0026rsquo;s absolutely true. Unfortunately, this is a recurring problem in mobility since we must save as much as possible the network consumption of the mobile device we have in our hands:\nnetwork loss weak networks (Edge, 3G,\u0026hellip;) \u0026hellip; It is therefore important to know how to manage data caching in order to provide a meaningful user experience.","title":"Kotlin: Cache Managment"},{"content":" Firebase is a very complete service offered by Google that allows a large number of things:\nAuthentication Database Storage Hosting Functions ML Kit Crashlytics Performance Test Lab \u0026hellip; And many other things!\nThe part we are interested in today is the cloud function.\nAs you probably know, cloud functions are simple pieces of code executed on demand. They are generally serveless and can therefore be executed anywhere and at any time without being repeated in a specific context.\nTherefore we will need triggers that will allow us to trigger the execution of a function. There are very simple triggers such as an HTTP call or database update.\nBut firebase also offers other types of triggers that can be used such as :\nCloud Firestore Triggers Realtime Database Triggers Remote Config Triggers Google Analytics for Firebase Triggers Crashlytics Triggers Cloud Storage Triggers Cloud Pub/Sub Triggers HTTP Triggers So we can imagine a whole bunch of scenarios like sending an email / an automatic notification to a user when he sends us a crashlytics report due to a bug in our application, it increases the quality of our application and the user experience but it costs us almost nothing as a developer.\nAs a mobile developer and iot I often need an API for my applications. The most common case is user administration for a website. We want to be able to:\nlist users creates a new user disable a user activate a user It should be noted that cloud functions run NodeJS, so we can use any library we want to create our API. Express being my favorite is what we\u0026rsquo;re going to use now.\nFirst of all we need to create our Firebase Function project. To do this, place yourself in a blank folder and execute the following command:\nIf you do not have to install the firebase tools, execute this command:\nfirebase init You should see the following choices in front of you:\nnpm install -g firebase-tools You should see the following choices in front of you:\nThen select your project.\nThe firebase tools will now create a complete cloud function project ready to be deployed for you. An index.js file will be created. This is the file that will be executed on the firebase platform. You can create other files but they must always be used in the index.js file.\nLike any NodeJS project, we will have a package.json file containing all our dependencies and a node_modules folder that will contain all the downloaded dependencies. So don\u0026rsquo;t forget to execute the command to install the packets:\nnpm i Let\u0026rsquo;s start by installing express and setting up the exit of a first road:\nnpm i express --save Let\u0026rsquo;s put the following code in the index.js file :\nconst functions = require(\u0026#39;firebase-functions\u0026#39;); const admin = require(\u0026#39;firebase-admin\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const app = express(); admin.initializeApp(); The libraries \u0026ldquo;firebase-functions\u0026rdquo; and \u0026ldquo;firebase-admin\u0026rdquo; will be necessary for the proper functioning of our API.\nLet\u0026rsquo;s create the first endpoint to test our function:\napp.get(\u0026#39;/test\u0026#39;, (req, res) =\u0026gt; { res.status(200).send(\u0026#39;It works!\u0026#39;) }); Nothing complicated, just sent us back text from the moment we call the route /test.\nWe no longer have any cases left where our express app is linked to an endpoint cloud function. To do this, simply enter this code:\nexports.admin = functions.https.onRequest(app); admin is the name of our cloud function.\nTo test in real conditions, we will have to deploy our cloud function. To do this, we just need to execute the following command:\nfirebase deploy You should now see this in the Dashboard tab:\nIn this picture, the part in red is the address where you can call your cloud function. Don\u0026rsquo;t forget to add /test in our case for this to work.\nUse software such as postman to make our request and test. Everything should work perfectly. If not, go to the \u0026ldquo;Logs\u0026rdquo; tab of the firebase to better understand what happened.\nUser API # As we said earlier, we want to list users, enable/disable them and be able to create new ones.\nLet\u0026rsquo;s start by creating a new user:\nAs required by the convention, for a creation we use the POST method.\napp.post(\u0026#39;/createAdmin\u0026#39;, async (req, res) =\u0026gt; { try { const userInDto = dto.createUserInDto(req); await admin.auth().createUser({ email: userInDto.email, emailVerified: false, password: userInDto.password, displayName: userInDto.username, disabled: false }); res.status(201).send(\u0026#39;\u0026#39;); } catch (ex) { console.log(\u0026#39;error\u0026#39;, ex); res.status(400).send( dto.createErrorOutDto( 100, \u0026#39;Something goes wrong!\u0026#39; ) ); } }); In order to be a little cleaner, I created a dto.js file that contains some very useful methods to convert incoming data to model and vice versa.\nfunction createUserInDto(req) { if (req.method !== \u0026#39;POST\u0026#39;) { console.log(\u0026#39;request method is not POST\u0026#39;, req); throw new Error(\u0026#39;Not POST methods\u0026#39;); } const val = req.body; if (!(\u0026#39;username\u0026#39; in val) || !(\u0026#39;password\u0026#39; in val) || !(\u0026#39;email\u0026#39; in val)) { console.log(\u0026#39;some data isnt ok\u0026#39;, val); throw new Error(\u0026#39;Malformed JSON Body\u0026#39;); } return { username: val.username, password: val.password, email: val.email } } function createErrorOutDto(code, ex) { return { errorCode: code, errorMessage: ex } } function createFirebaseUserOutDto(json) { return { id: json.uid, email: json.email, username: json.displayName !== undefined ? json.displayName : \u0026#39;\u0026#39;, disabled: json.disabled, } } module.exports = { createUserInDto: createUserInDto, createErrorOutDto: createErrorOutDto, createFirebaseUserOutDto: createFirebaseUserOutDto } As you can see nothing complicated here, we retrieve the data from the request and use the createUser method of the firebase-admin library to create a new user.\nAs for the activation or deactivation, nothing more complicated:\napp.put(\u0026#39;/user/enable/:id\u0026#39;, async (req, res) =\u0026gt; { changeUser(req, res, true); }); app.put(\u0026#39;/user/disable/:id\u0026#39;, async (req, res) =\u0026gt; { changeUser(req, res, false); }); async function changeUser(req, res, enable) { try { const userId = req.params.id; if (userId === undefined || userId === null) { throw new Error(\u0026#39;userId is not set\u0026#39;); } await admin.auth().updateUser(userId, { disabled: !enable }); res.status(200).send(\u0026#39;\u0026#39;); } catch (ex) { res.status(400).send( dto.createErrorOutDto( 100, \u0026#39;Something goes wrong!\u0026#39; ) ); } } All we have to do now is list all the users of the database.\napp.get(\u0026#39;/users\u0026#39;, async (req, res) =\u0026gt; { try { const users = await admin.auth().listUsers(); let result = []; users.users.forEach((userRecord) =\u0026gt; { const newUser = dto.createFirebaseUserOutDto(userRecord.toJSON()); result.push(newUser); }); res.status(200).send(result); } catch (ex) { res.status(400).send( dto.createErrorOutDto( 100, \u0026#39;Something goes wrong!\u0026#39; ) ); } }); Securing the API # We were able to make all the requests we wanted and quite easily. Now it is a question of securing our API in order to prevent anyone from calling it directly without our permission. To do this we will simply add an API key.\nFor that we will add a verification middleware. It will have to be placed before our requests if we want it to take effect:\nconst apiKeyMiddleware = (req, res, next) =\u0026gt; { const apiKeyHeader = req.headers.apikey; if (apiKeyHeader === config.apiKey) { next(); return; } else { res.status(401).send(\u0026#39;\u0026#39;); } }; Replace the config.apiKey by the key you want to use.Then call the middleware:\napp.use(apiKeyMiddleware); You no longer have to call the API with our key in the headers. And here is your API for firebase users is ready.\n","date":"18 April 2021","permalink":"/blog/posts/firebase-functions/","section":"Posts","summary":"Firebase is a very complete service offered by Google that allows a large number of things:\nAuthentication Database Storage Hosting Functions ML Kit Crashlytics Performance Test Lab \u0026hellip; And many other things!\nThe part we are interested in today is the cloud function.\nAs you probably know, cloud functions are simple pieces of code executed on demand. They are generally serveless and can therefore be executed anywhere and at any time without being repeated in a specific context.","title":"Firebase : Functions"},{"content":" Firebase # As I have already mentioned in this article, Firebase is a service offered by Google for mobile and web developers to facilitate a large number of parts of application development:\nAuthentication NoSql Database cloud function Storage (image, video, \u0026hellip;) Web application hosting Real-time database Test lab Crash reporting in real time Remote config Cloud messaging It is therefore a very useful service for the rapid prototyping of an application and even for an application in production and all this for a very modest price.\nAzure DevOps # Azure DevOps is a service offered by Microsoft and the direct descendant of VSTS and Team Foundation. It is an online service that allows you to manage a number of things:\nBacklog management (scrum, agile,\u0026hellip;) Git directory management Test Plan Management Artifacts management Pipeline management All the tools necessary to manage a development team, both from the point of view of the Product Owner and the developer.\nCloud function # Definition # Have you already done cloud functions? If you do not know this is a code that is triggered according to an event and starts processing. The most frequently encountered cases are:\nSending an email when creating a user Receiving an http request Modifying a field in a database The principle of a cloud function is that it is called \u0026ldquo;serverless\u0026rdquo;. Therefore, there is no need to take care of the server that is located and no need to manage the load, since it is possible to create as many as one trigger triggered.\nMany offers exist on the net to create and host cloud function:\nMicrosoft with Azure Functions Google with GCP Cloud Function Google with Firebase Function IBM with IBM Cloud Function Parse with Cloud Code Amazon with AWS Lambda Red Hat with OpenShift Cloud Function We therefore encounter more and more of them and it becomes important to know this type of service.\nSample # To practice a little, we will create a very simple code for the Firebase cloud function. This function will be placed on an HTTP request.\n\u0026#39;use strict\u0026#39;; const functions = require(\u0026#39;firebase-functions\u0026#39;); const moment = require(\u0026#39;moment\u0026#39;); const cors = require(\u0026#39;cors\u0026#39;)({ origin: true, }); exports.date = functions.https.onRequest((req, res) =\u0026gt; { return cors(req, res, () =\u0026gt; { let format = req.query.format; if (!format) { format = req.body.format; } const formattedDate = moment().format(format); console.log(\u0026#39;Sending Formatted date:\u0026#39;, formattedDate); res.status(200).send(formattedDate); }); }); The purpose of this code, as simple as it may be, is to return the server date according to the format sent (via the request or the body). If you have never done a Firebase cloud function before, that here \u0026ldquo;exports.date\u0026rdquo; allows you to expose the cloud function which will be named \u0026ldquo;date\u0026rdquo; and will be present in the url of it.\nIf you want to have a large number of examples, I invite you to visit Google\u0026rsquo;s GitHub for Firebase: https://github.com/firebase/functions-samples\nPractice # Let\u0026rsquo;s start by creating a new pipeline. For simplicity\u0026rsquo;s sake, I advise you to host your git directly on DevOps. Select Azure Repos Git. If not, choose the provider that suits you.\nOnce you have selected your git, you will be able to select the basic configuration. This is a simple tool that will pre-construct a yaml script containing a set of pre-defined tasks for the chosen project type. Of course, everything can be modified at will.\nIn our case, we will select Node.js as you can see below.\nThe following script will have been generated. It is interesting but does not yet allow us to deploy on firebase. To do this, we will have to make some changes.\n# Node.js # Build a general Node.js project with npm. # Add steps that analyze code, save build artifacts, deploy, and more: # https://docs.microsoft.com/azure/devops/pipelines/languages/javascript trigger: - master pool: vmImage: \u0026#39;ubuntu-latest\u0026#39; steps: - task: NodeTool@0 inputs: versionSpec: \u0026#39;10.x\u0026#39; displayName: \u0026#39;Install Node.js\u0026#39; - script: | npm install npm run build displayName: \u0026#39;npm install and build\u0026#39; The main gap is the set of Firebase commands and in particular firebase deploy:\n# Node.js # Build a general Node.js project with npm. # Add steps that analyze code, save build artifacts, deploy, and more: # https://docs.microsoft.com/azure/devops/pipelines/languages/javascript trigger: - master - develop pool: vmImage: \u0026#39;ubuntu-latest\u0026#39; steps: - task: NodeTool@0 inputs: versionSpec: \u0026#39;10.x\u0026#39; displayName: \u0026#39;Install Node.js\u0026#39; - script: | cd functions npm install -g firebase-tools npm install firebase deploy --token $(firebase-token) --project $(firebase-project) --only functions --force displayName: \u0026#39;npm install and deploy\u0026#39; As you can see in lines 7 and 8, this pipeline is triggered on a commit (merge in theory: you don\u0026rsquo;t directly commit to master or develop by pity! 😤) of master as well as develop. It is up to you to change these values if you want a different behaviour.\nAs the execution of commands is not related to the OS we are on (vive nodeJs and its cross compatibility), we will use ubuntu.\nAs I said earlier, we will need NodeJs to work. This installation will also add NPM. In the current script I ask for a version 10 of NodeJS, if you are compatible with newer versions, you can quite let it choose \u0026rsquo;latest\u0026rsquo;.\nOnce NodeJS is installed, there is no magic, you will have to execute exactly the same commands as on your development machine. To do this we need the Firebase tools. Here again nothing new, we use the command npm install -g firebase-tools to add them.\nWe then update our node_modules with the command npm i or npm install.\nIn this case I use JS directly, so there is no need to transpose anything (e. g. typescript) but it is quite possible for you to do so too. Remember that you are on a \u0026ldquo;classic\u0026rdquo; machine and can therefore add tools.\nWe can therefore proceed directly to deployment on Firebase. But here a small problem arises: my credentials.\nIn theory on your development machine no problem, you enter your credentials on the fly and they are safe in your head (or worse on a Post-It 😡). But leave them lying around on a build machine that doesn\u0026rsquo;t belong to you\u0026hellip; well, I don\u0026rsquo;t recommend it! Even if Microsoft does not use them, it is a very bad practice. Therefore, we will use the \u0026ldquo;Variables\u0026rdquo; tab provided for the DevOps tool.\nTo do this, click on the \u0026ldquo;Variables\u0026rdquo; button just above the editing area of the pipeline script:\nYou will see the following popup displayed:\nAs you can see, I have personally already entered two hidden variables: firebase-project and firebase token.\nYou will find them in particular in line 23 of the pipeline script. They are the ones that allow for safe deployment. This way, if another member of your team has access to your pipeline but you do not want them to see/use your credentials, it is now possible.\nIt is now possible for you to automatically deploy your code on Firebase ! Isn\u0026rsquo;t that wonderful? If you wish to test it, simply click on the \u0026ldquo;Run\u0026rdquo; button located at the same level as the \u0026ldquo;Variable\u0026rdquo; button or save and commit to the trigger branch(s) of this pipeline.\nDon\u0026rsquo;t forget that Azure DevOps offers you 1800 minutes per month of shared pipeline. Something to start having fun and even work with 😍.\n","date":"18 April 2021","permalink":"/blog/posts/firebase-azure-devops/","section":"Posts","summary":"Firebase # As I have already mentioned in this article, Firebase is a service offered by Google for mobile and web developers to facilitate a large number of parts of application development:\nAuthentication NoSql Database cloud function Storage (image, video, \u0026hellip;) Web application hosting Real-time database Test lab Crash reporting in real time Remote config Cloud messaging It is therefore a very useful service for the rapid prototyping of an application and even for an application in production and all this for a very modest price.","title":"Firebase and Azure DevOps"},{"content":" Upload flutter projet on Google Play # Have you ever tried flutter? If not, I invite you to do it, it\u0026rsquo;s worth a visit!\nBut did you go as far as publishing on stores and especially on Google Play?\nI personally tried to publish an application made with this technology on Google Play but I found myself faced with an unexpected error:\nThat\u0026rsquo;s a problem!\nFortunately Android Studio allows us to compile for several platforms in the same APK but also to compile several APK, each for a different platform!\nFirst of all, add the following code to your \u0026ldquo;app/build.gradle\u0026rdquo; file:\nsplits { abi { enable true reset() include \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;arm64-v8a\u0026#34; universalApk false } } From there, at each compilation you will generate several APKs. One per platform, here armeabi-v7a and arm64-v8a.\nNow you can start compiling for both platforms.\nflutter build apk --release --target-platform=android-arm An APK with the name app-armeabi-v7a-release.apk will be generated. Note that the 2 APKs will be generated each time but it is important to use only the one mentioned above.\nNow increment the CodeVersion property of your project otherwise Google Play will refuse your new APK:\nYou can now generate the second APK with the command:\nflutter build apk --release --target-platform=android-arm64 The new APK will be appointed app-arm64-v8a-release.apk.\nThe Google Play console should accept this second APK without any problem. Repeat the check and everything should work fine!\nAlso remember that it is essential to prepare for the future with the new APK x64.\nSo since this is a Google technology, we can imagine that a solution will be considered very soon!\nI hope this article will get you more! Feel free to contact me to discuss further ;)\n","date":"18 April 2021","permalink":"/blog/posts/upload-flutter-googleplay/","section":"Posts","summary":"Upload flutter projet on Google Play # Have you ever tried flutter? If not, I invite you to do it, it\u0026rsquo;s worth a visit!\nBut did you go as far as publishing on stores and especially on Google Play?\nI personally tried to publish an application made with this technology on Google Play but I found myself faced with an unexpected error:\nThat\u0026rsquo;s a problem!\nFortunately Android Studio allows us to compile for several platforms in the same APK but also to compile several APK, each for a different platform!","title":"Upload flutter project on Google Play"}]