[{"content":" You may have already had it but there is a bug on UITextField only on iOS emulators (iPhone and iPad). It may happen that when you select a UITextField your application freezes like the picture below:\nNow that your application looks like this, you cannot do anything and you have to restart your application.\nvia GIPHY\n This is a bug known by the Apple team and originally seemed to affect only the iOS 13 version. But I can confirm that I also encountered it on emulators with version 14.\nBut I reassure you, nothing comes from your code but from the emulator itself. So even if you are not anative developer, you may encounter this problem, as here for NativeScript :\n![https://github.com/NativeScript/NativeScript/issues/7919#issue-504001839]\nBut then how to solve it?\nWell, it\u0026rsquo;s very simple! Just restart your emulator.I hope this helped you and that unlike me, you won\u0026rsquo;t spend 2 hours looking for a solution in your code.\n","date":"4 January 2022","permalink":"/posts/uitextfield-bug/","section":"Posts","summary":"You may have already had it but there is a bug on UITextField only on iOS emulators (iPhone and iPad).","title":"UITextField bug ðŸ˜±"},{"content":" What is a file attribute? # I will probably push an open door, but a file system has attributes on the files. In particular, the read, write and execute of each file and this for the different groups:\n-rw-rw-r-- 1 kelvas users 5120 Jul 09 04:30 sample.txt But these attributes were not enough for many cases. So an extension was added to the inodes to allow more functionality on the files: the extended attributes or xattr.\nHow it works # Unlike regular attributes, extended attributes are not interpreted by the file system, but are stored and managed separately. Any extended attribute is identified by a pair (name:value) that allows manipulation of the stored information.\nSome file systems require special mount options to enable support for extended attributes.\nLinux and macOS # Many Linux distributions include the extended attributes and also macOS since version 10.4 thanks to the HFS+ file system.\nOkay, but why? # You\u0026rsquo;re going to say to me, \u0026ldquo;Why are you talking about this today?\u0026rdquo;. Well, it\u0026rsquo;s quite simple. You know I like to code and I like to share. Well recently I had to share a macOS application with a friend and he could never open the application because of this error:\nStrange because I tested the application just before sending it and everything worked perfectly. Of course, my first reflex was to make him re-download the ZIP containing the application: without success. My second reflex was to question my ZIP and to change for a TAR or a GZIP: no change yet.\nAnd it\u0026rsquo;s after several research that I discovered these famous xattr.Once downloaded and unzipped, the application had the following attributes:\ncom.apple.quarantine: 0083;61b9bd2d;Safari;7E8E7E48-6187-4915-BF12-2FF346BF1306 As the application was not downloaded from the store, it was automatically quarantined by the system, which of course prevents the execution of the software even though the \u0026ldquo;standard\u0026rdquo; attribute of execution is valid for the user and his group.\nTo see the list of extended attributes, you will need this command:\nxattr -l path/to/myFile.ext And if you need to remove all extended attributes from a file, this command will be very useful:\nxattr -cr path/to/myFile.ext In my case removing the quarantine, attribute allowed me to launch the application. Of course, I invite you to be careful with the management of these attributes that are used by the system and the applications to work properly.\n","date":"2 January 2022","permalink":"/posts/macos-xattr-attributes/","section":"Posts","summary":"What is a file attribute?","title":"macOS xattr attributes"},{"content":" The pillars of the software (1/2) # Today we will leave the mobile topics and talk about the thousands of software. What I mean here by pillar is the software / libraries that everyone uses directly or indirectly (via other software / libraries). And we will see together that a lot relies on little and that is a bit scary!\nActually I wanted to talk about this because I came across this tweet from Mike van Riel (@mvriel: https://twitter.com/mvriel) a fellow developer who posted this:\nI think you agree with me, it\u0026rsquo;s sobering. And it\u0026rsquo;s true that I had never thought about it before! So I got interested in the subject and wanted to share with you what I discovered!\ncURL # Let\u0026rsquo;s start with the one we all used at least once, the one we see everywhere in API examples, the one we are taught in school: cURL.\nIt was created in 1998 by Daniel Stenberg (https://en.wikipedia.org/wiki/Daniel_Stenberg) and if you don\u0026rsquo;t know, cURL stands for \u0026ldquo;Client URL\u0026rdquo;.\nIt is available on GitHub at this address: https://github.com/curl/curl\nIt allows to transfer data through a multitude of protocols: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. curl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2, HTTP/3, \u0026hellip;\nAnd according to their site, cURL is also used in cars, TVs, routers, printers, audio equipment, cell phones, tablets, set-top boxes, media players and is the Internet transfer engine for thousands of software applications in over ten billion installations.\nIf I were the creator of this marvel I would be really proud of the success of my software. Because yes, when we reach more than 10 billion installations, I think we can easily talk about success!\nHere is the official website of the software: https://curl.se/\nBut who maintains the software?\nIf we believe GitHub and the contributors page they are, at the time of writing, 729 contributors. But this count includes all contributors: from those who added a feature to those who corrected a spelling mistake in a comment to those who fixed security holes.\nSo let\u0026rsquo;s take a look at the top contributors.\nAs you can see, we fall very quickly below the thousand of commits per developer and that therefore, we have mainly 3 main developers on the subject! The first is badger the creator of cURL, which seems logical.\nThe second one is yangtse and his profile does not include any information. So let\u0026rsquo;s consider that he is a person interested but not necessarily related to cURL.\nAnd the third one is Steve Holme who works for cURL if we believe his GitHub profile.\nSo we can see that indeed, despite the strong use and popularity of the software, there is almost nobody on the subject. Everything rests on the shoulders of 3 people.\nWhich, let\u0026rsquo;s face it, can be scary! Imagine that tomorrow they decide to retire, or that they are no longer passionate about this project. What will happen? So I know that the open source community is supposed to take over, but we all know that taking over someone else\u0026rsquo;s development is always complicated. Especially when the project has been around for so long.\nSo as Mike van Riel said, cURL doesn\u0026rsquo;t rely on many people and yet it\u0026rsquo;s one of the most used software/libraries in the world!\nIt makes you think!\n","date":"15 July 2021","permalink":"/posts/pillars-software-1-on-2/","section":"Posts","summary":"The pillars of the software (1/2) # Today we will leave the mobile topics and talk about the thousands of software.","title":"The pillars of the software (1/2)"},{"content":" Segmentation fault and .NET on Linux # For some time I have re-enabled one of my PC with a good Linux Manjaro, it\u0026rsquo;s very convenient to run tens of services continuously without having to leave my Mac on or at home.\nAnd I wanted to experience .NET development with VSCode (to do Blazor I admit it) all on my Linux.\nOf course I follow the Microsoft tutorials to set up the environment and I start here: https://docs.microsoft.com/en-us/dotnet/core/install/linux-snap\nWhen I get to the \u0026ldquo;Install SDK\u0026rdquo; step, we are asked to use this command:\nsudo snap install dotnet-sdk --classic --channel=5.0 Nothing more normal on my Linux (well from my short experience), we use the snap utility to download, install and manage the .NET SDK. I continue with the runtime. So far so good. I end up installing VSCode, still from snap.\nAnd finally comes the long awaited moment to start a new project. As I use VSCode and not Visual Studio it is necessary to create the projects via command line and not via the graphical interface :\ndotnet new blazorserver -o BlazorApp --no-https And then it\u0026rsquo;s drama! ðŸ˜­ :\nSegmentation fault (core dumped) Impossible to create projects. The tool crashes no matter what type of project I want to create. So I start looking for a solution on the Internet. After several ten minutes of research I end up on this link: https://github.com/dotnet/sdk/issues/11639\nThey talk about the DOTNET_CLI_TELEMETRY_OPTOUT variable which is the cause of the problem. After an attempt on my side the behavior persists. No solution seems to work until I see the comment of Wowo10 :\nAnd there to the miracle it works! ðŸŽ‰\nHere are the commands if you need them:\nsudo snap remove dotnet-sdk sudo pacman -S dotnet-sdk Other comments suggest that downloading .NET via pacman and apt-get works but not via snap. So if you also have the problem, I invite you to use these commands to get your .NET SDK working properly.\nWhat is quite strange is that nothing is specified on the Microsoft website and that it seems to come from Snap. However, the problem seems to be present since 2019 even if the ticket is closed only since yesterday. Maybe we\u0026rsquo;ll get to the bottom of this one day.\nUntil then, have fun with .NET on Linux!\n","date":"4 July 2021","permalink":"/posts/segmentation-fault-dotnet-linux/","section":"Posts","summary":"Segmentation fault and .","title":"Segmentation fault and .NET on Linux"},{"content":" As you\u0026rsquo;ve probably gathered from the previous articles, I mostly do iOS and Android mobile. But from time to time, I go outside this mobile bubble to do other things.\nThe interesting thing about doing Xamarin for mobile is that it\u0026rsquo;s easy to port our application to desktop environments. But when I left my iOS and Android cocoon, I quickly realized that the tools for desktop development were not necessarily as advanced as their smartphone brother.\nAnd finally: especially on MacOS!\nThe problem # From time to time during the development of one of my applications, I found myself with crashes of this one without stacktrace or exception that .NET had accustomed me to until now. But only a good old dump like this one :\n================================================================= Native Crash Reporting ================================================================= Got a abrt while executing native code. This usually indicates a fatal error in the mono runtime or one of the native libraries used by your application. ================================================================= ================================================================= Native stacktrace: ================================================================= 0x1041d28a6 - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_dump_native_crash_info 0x1041c647e - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_handle_native_crash 0x1041d1eaf - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : sigabrt_signal_handler 0x7fff2039fd7d - /usr/lib/system/libsystem_platform.dylib : _sigtramp 0x7fff20326133 - /usr/lib/system/libsystem_kernel.dylib : host_create_mach_voucher 0x7fff20348fef - /usr/lib/system/libsystem_kernel.dylib : __darwin_check_fd_set_overflow.cold.1 0x7fff24b010ae - /System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC : __TCCAccessRequest_block_invoke_2 0x7fff24b018df - /System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC : __TCCAccessRequest_block_invoke.138 0x7fff24aff504 - /System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC : __tccd_send_message_block_invoke 0x7fff200a1a9c - /usr/lib/system/libxpc.dylib : _xpc_connection_reply_callout 0x7fff200a1a24 - /usr/lib/system/libxpc.dylib : _xpc_connection_call_reply_async 0x7fff201b0870 - /usr/lib/system/libdispatch.dylib : _dispatch_client_callout3 0x7fff201c9035 - /usr/lib/system/libdispatch.dylib : _dispatch_mach_msg_async_reply_invoke 0x7fff201c051c - /usr/lib/system/libdispatch.dylib : _dispatch_kevent_worker_thread 0x7fff203574a5 - /usr/lib/system/libsystem_pthread.dylib : _pthread_wqthread 0x7fff2035642f - /usr/lib/system/libsystem_pthread.dylib : start_wqthread ================================================================= Telemetry Dumper: ================================================================= Thread 0x30d034000 may have been prematurely finalized* Assertion at /Users/builder/jenkins/workspace/archive-mono/2020-02/mac/release/mono/utils/mono-threads.c:650, condition `info' not met, function:mono_thread_info_current, I might as well tell you that when you read lines like :\n0x1041d28a6 - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_dump_native_crash_info 0x1041c647e - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : mono_handle_native_crash 0x1041d1eaf - /Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp : sigabrt_signal_handler We are not very serene on the way to solve this. We find ourselves without any concrete clue and we end up doing what my grandfather used to do: put print(\u0026ldquo;Foo\u0026rdquo;) everywhere to know where the code stops.\nBeyond the fact that this technique is very annoying, it is also doomed to failure as soon as you manage several Threads and/or your application makes several hundreds/thousands lines of code with hundreds of different classes.\nPossible solutions # AOT # According to Chris Hamons (https://github.com/chamons), one of the main contributors to Xamarin.Mac, you can enable Ahead Of Time compilation on your project to get a better stacktrace and therefore potentially more research and reflection on your problem.\nAOT compilation is a compilation that translates a high-level language into machine language before the execution of a program, as opposed to just-in-time compilation, which is done at runtime.\nPre-compilation allows you to have a global view of the code, which is not the case with on-the-fly compilation, which can only make local optimizations. Early compilation allows to reduce the costs of exception handling and calls to methods and interfaces.\nUnfortunately this technique is not always possible. In my personal case I use the SQLite library which prevents the passage in AOT.\nMoreover, it is to be noted that this technique is to be applied only in debug, since the produced code is more voluminous and less fast. So remember to disable it before compiling in release.\nThe console # You may know it but the \u0026ldquo;Console\u0026rdquo; program on MacOS allows you to see everything that is happening on your machine. It is the equivalent of \u0026ldquo;Event Viewer\u0026rdquo; on Windows or \u0026ldquo;Logcat\u0026rdquo; on Android.\nFor some problems, it is my best friend. Being system specific and not linked to your application, it is able to log more information about crashes than your own application with its logger.\nMoreover, belonging to the system, it has a different point of view. It will give you additional information about what the system is doing with your application: adding an event, deleting an event, system warning, certificate problem, \u0026hellip;\nHow to use the console to debug? # You will see, it is quite simple, not to say childish. First of all, open the Console application. Your application must always be turned off.\nThen activate the log capture with the central button:\nYou will now see a large amount of logs appearing on your screen. These concern the whole system and all applications. No question of sorting out all this ourselves.\nIn the search bar type the name of your application or its bundle id. You will see that normally all the logs will disappear to leave a blank page.\nNow launch your application in debug and try to reproduce your crash.\nThe logs will start to appear. Of course, all the logs do not necessarily represent an error. It is all the information that the system sees fit to expose.\nOnce your crash has been reproduced, go to the console and look at the last logs present in the console, they will surely help you! In my case, for example, it was a lack of permission in the Info.plist. And I was able to find this out thanks to this line:\nRefusing authorization request for service kTCCServiceBluetoothAlways and subject Sub:{com.kevinsibue.myapp}Resp:{identifier=\u0026lt;ID of InvalidCode\u0026gt;, pid=11337, auid=501, euid=501, binary_path=/Users/myUser/Documents/Projects/MyApp/MyApp/bin/Debug/MyApp.app/Contents/MacOS/MyApp} without NSBluetoothAlwaysUsageDescription key So we are far from the original dump that made me want to tear my hair out. And at least here the error is clear! Our application is killed because it doesn\u0026rsquo;t have in the Info.plist the NSBluetoothAlwaysUsageDescription key. I just have to add it to make the error disappear.\nCrashes # In general, if your application crashes, we are never sure to have the information in the application logs.\nThe method we have seen before is interesting but requires to open the console before using the application. And clearly your customers won\u0026rsquo;t do it and maybe your testers won\u0026rsquo;t either.\nThe first solution would be to set up a bug reporter like AppCenter or Firebase Crashlytics. They work very well for mobile. But no such luck for Xamarin.Mac applications.\nFortunately, it is possible to access the crash log directly on your Mac.\nStill in the Console application, and you will be in the left sidebar, subsection \u0026ldquo;Report\u0026rdquo; the item \u0026ldquo;Blocking report\u0026rdquo;. This one will contain all the crash logs recorded by the system for your application!\nProcess: MyApp [11218] Path: /Users/USER/Documents/*/MyApp.app/Contents/MacOS/MyApp Identifier: com.kevinsibue.myapp Version: 48.8 (1) Code Type: X86-64 (Translated) Parent Process: ??? [1] Responsible: MyApp [11218] User ID: 501 Date/Time: 2021-06-12 16:16:10.842 +0200 OS Version: macOS 11.4 (20F71) Report Version: 12 Anonymous UUID: ACE4D874-1610-4A86-D6EE-681EE74AD581 Sleep/Wake UUID: E83C9115-81A1-4AF3-91E2-BE359E9F4A2B Time Awake Since Boot: 28000 seconds Time Since Wake: 460 seconds System Integrity Protection: enabled Crashed Thread: 7 Thread Pool Worker Exception Type: EXC_BAD_ACCESS (SIGABRT) Exception Codes: KERN_INVALID_ADDRESS at 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY VM Regions Near 0: --\u0026gt; __TEXT 104738000-104cd0000 [ 5728K] r-x/r-x SM=COW /Users/*/Documents/*/MyApp.app/Contents/MacOS/MyApp Application Specific Information: abort() called Thread 0:: tid_103 Dispatch queue: com.apple.main-thread 0 ??? 0x00007ffe94316ab8 ??? 1 libsystem_kernel.dylib 0x00007fff203252ba mach_msg_trap + 10 2 com.apple.CoreFoundation 0x00007fff204538c5 __CFRunLoopServiceMachPort + 316 3 com.apple.CoreFoundation 0x00007fff20451f7b __CFRunLoopRun + 1332 4 com.apple.CoreFoundation 0x00007fff20451380 CFRunLoopRunSpecific + 567 5 com.apple.HIToolbox 0x00007fff288f1ab3 RunCurrentEventLoopInMode + 292 6 com.apple.HIToolbox 0x00007fff288f1815 ReceiveNextEventCommon + 587 7 com.apple.HIToolbox 0x00007fff288f15b3 _BlockUntilNextEventMatchingListInModeWithFilter + 70 8 com.apple.AppKit 0x00007fff22b7c6f2 _DPSNextEvent + 864 9 com.apple.AppKit 0x00007fff22b7aec5 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1364 10 com.apple.AppKit 0x00007fff22b6d239 -[NSApplication run] + 586 11 com.apple.AppKit 0x00007fff22b4147c NSApplicationMain + 816 12 ??? 0x0000000118183147 ??? 13 ??? 0x0000000118182df3 ??? 14 ??? 0x0000000110fd97fb ??? 15 ??? 0x0000000110fd9971 ??? 16 com.kevinsibue.myapp 0x00000001048631ce mono_jit_runtime_invoke + 1550 (mini-runtime.c:3191) 17 com.kevinsibue.myapp 0x00000001049982d8 do_runtime_invoke + 54 (object.c:3052) [inlined] 18 com.kevinsibue.myapp 0x00000001049982d8 mono_runtime_invoke_checked + 136 (object.c:3220) 19 com.kevinsibue.myapp 0x000000010499f605 do_exec_main_checked + 60 [inlined] 20 com.kevinsibue.myapp 0x000000010499f605 mono_runtime_exec_main_checked + 117 (object.c:5284) 21 com.kevinsibue.myapp 0x00000001047bf59c mono_jit_exec_internal + 14 (driver.c:1383) [inlined] 22 com.kevinsibue.myapp 0x00000001047bf59c mono_jit_exec + 364 (driver.c:1328) 23 com.kevinsibue.myapp 0x00000001047c2696 main_thread_handler + 71 (driver.c:1465) [inlined] 24 com.kevinsibue.myapp 0x00000001047c2696 mono_main + 8790 (driver.c:2714) 25 com.kevinsibue.myapp 0x00000001047775bc xamarin_main + 1116 (launcher.m:656) 26 com.kevinsibue.myapp 0x0000000104778434 main + 36 (launcher.m:675) 27 libdyld.dylib 0x00007fff20375f5d start + 1 And these logs are available even without activating the console before a test. Quite practical!\nThere is already a very good article from Microsoft on the subject: https://docs.microsoft.com/fr-fr/xamarin/mac/deploy-test/debugging-native-crash. I invite you to read it to better manage these error cases.\n","date":"12 June 2021","permalink":"/posts/incomprehensible-errors/","section":"Posts","summary":"As you\u0026rsquo;ve probably gathered from the previous articles, I mostly do iOS and Android mobile.","title":"Incomprehensible errors"},{"content":" If you like to share and you make code, you probably have a GitHub, GitLab or other account to share your interesting pieces of code to the world.\nLike any Git repo, you\u0026rsquo;re going to have a README file. And you may not know it yet, but this is perhaps the most important part of your repo.\nBeyond your code and its quality, when you share code, it is important that developers who find your code can easily understand what it is about and especially to give them confidence in you, even if they have never seen you before and do not (yet) know your work.\nWhat are the important points to address then?\nDependencies # Most, if not all, mobile applications have dependencies on other frameworks or libraries. It is important to take them into account for your README, since they may induce limitations or links not desired by the developer using your code.\nThe platform and the framework # Let\u0026rsquo;s start with the most obvious and the one that is mandatory in all cases: platforms and framework.\nLet\u0026rsquo;s take the case of the construction of a Swift Package. This one will contain Swift code created by you in order to facilitate the use of TableViews for example. Therefore your code is directly dependent on UIKit containing the UITableView.\nTherefore, your Swift code which until now was universal is only available if UIKit is also universal and therefore on iOS and iPadOS.\nIt is therefore essential that you indicate in your README three points: UIKit, iOS and iPadOS. These dependencies may prevent another developer from using your code, so you must inform him very quickly to avoid any confusion or problem.\nThird-party dependencies # As well as the platform or system framework used, it is possible that you use a third party dependency. It is also necessary to specify this dependency for several reasons.\nThe application that will use your code may already use the same dependency but in another version, which can cause problems.\nBut even worse, the third party dependency have no guarantee of long term support. It is the creator with his community (if it exists) that maintains the existing code. This means that maybe, one day, nobody will be there to fix the bugs or make the necessary evolutions to support the new versions of the system.\nIt is therefore essential to properly specify these high-risk dependencies.\nThe tests # But how to give confidence to other developers? It\u0026rsquo;s very simple: the quality of your code. And the best way I know for that is simply unit tests!\nThey are essential to justify the use of your code. They allow anyone to be sure that you have done your work well. In addition, the analysis of unit tests allows you to quickly realize the quality of work and the way a developer works.\nThey are even more important when the developer\u0026rsquo;s goal is not to integrate your code but to fork it to make another version.\nAdd to this the code coverage and you have 2 strong arguments to easily allow the adoption of your code!\nThe people who trust us # Let\u0026rsquo;s not forget that few things have not already been done. So why take your solution rather than the neighbor\u0026rsquo;s?\nThe previous chapters are good reasons, but there is even better: the companies / communities / applications that use your code.\nIf you have companies like Uber or AirBnb embedding your code in their mobile app, it can only help you gain credibility.\nSo don\u0026rsquo;t forget to list those actors who believe in you!\nThe license # The license of your code is crucial for any developer who would like to use your code. Don\u0026rsquo;t forget that some of you will want to integrate it in your own code to share, others in their personal application and finally companies may need it for products they want to sell.\nIt\u0026rsquo;s up to you to specify the right license. If you are on GitHub, you can directly choose a license when creating your Git repo. This will create a LICENSE.md file at the root of your repo.\nHere is a reminder of the most used licenses:\nIf you have trouble choosing the most suitable license for your situation, here is a very good site with all the information you need: https://choosealicense.com/licenses/\nBadges # We have seen a lot of points that are important. But there is still one that, despite the little space it takes in your readme, I think is crucial: the badges.\nThey don\u0026rsquo;t take up space, they are simple and sober but allow a clear and simple message to be conveyed to everyone.\nI recommend to put them at the beginning of your README so that they serve as a summary of your repo. Developers will be grateful to you for this since they allow you not to linger too long on a repo that is not suitable.\nIf you want to know more about badges and how to generate them, I invite you to go to this site: https://shields.io/\nOverall body # Here is the body of your README in a nutshell:\n Title and image Badges (build, unit tests, code coverage, platforms, \u0026hellip;) Current version Requirements Features Installation Getting Started Change logs Contribute License  Of course this may change depending on the type of code you share. The \u0026ldquo;Installation\u0026rdquo; section is very useful when you share a Swift Package or a Cocoapods but not at all for a sample code.\nGood examples in my opinion # Rather than continuing to list the things that need to be addressed, let\u0026rsquo;s look at what others are doing that I think is right:\n https://github.com/firebase/firebase-ios-sdk https://github.com/ReactiveX/RxSwift https://github.com/stripe/stripe-ios  I hope this article will have more for you! Do not hesitate to share it and leave a comment!\n","date":"5 June 2021","permalink":"/posts/how-make-good-readme/","section":"Posts","summary":"If you like to share and you make code, you probably have a GitHub, GitLab or other account to share your interesting pieces of code to the world.","title":"How to make a good README?"},{"content":" In software development there is one thing that is difficult to achieve : quality.\nAnyone can code but few are able to code good software. When I say good I mean robust, stable and malleable according to the necessary evolutions.\nBut to guarantee such a quality you need tools. Beyond the timeless design pattern, debugging tools or other, there are especially unit tests.\nOf course making an iOS application in Swift is no exception to the rule. But as with any language there is always something quite complicated to test, namely asynchronism.\nIf you don\u0026rsquo;t have the answer to this question yet and you are a beginner in unit testing or Swift, then I invite you to read the rest of this article.\nLike any self-respecting program in iOS, we parallelise a maximum number of tasks. To do this, we need to use DispatchQueues which themselves generate callbacks or completionBlock. This only promises us that we will return to this place in the code at a given moment, but when?\nOn the other hand, a unit test is much simpler. It is just a function that runs synchronously.\nSo how to combine synchronous and asynchronous?\nIf like me you are used to C# nothing could be simpler. You just have to put the keyword async and return a Task type for everything to work. Unfortunately for us and for the moment before Swift 5.5 we have to work with callbacks.\n[TestMethod] public async Task SumTest_WhenInput1And2_Returns3() { var sum = await math.GetSumAsync(1, 2); sum.Should().Be(3) } In Swift, it will be necessary to wait for the end of the execution of our callback. But how to do this? How to play with time?\nWe all know a simple method to make code wait for a certain or infinite time until something asynchronous ends: a semaphore or a mutex.\nBut Apple has already provided for us and everything we need with the Expectation class.\nThis allows you to define a given time before the mutex is automatically released or the callback arrives.\nfinal class KVFaqResourceLoaderTests: XCTestCase { func test_load_validResource_Ok() throws { let expectation = XCTestExpectation(description: \u0026#34;Load local resource\u0026#34;) let resourceLoader = try KVFaqResourceLoader( bundleExplorer: KVFoundationBundleExplorer(), bundle: Bundle.module, resourceNameWithExtension: \u0026#34;faq.json\u0026#34; ) var loadData: Data? = nil var loadError: Error? = nil resourceLoader.load { (data, error) in loadData = data loadError = error expectation.fulfill() } wait(for: [expectation], timeout: 10.0) XCTAssertNotNil(loadData) XCTAssertNil(loadError) } } Nothing very complicated here. It is also possible to use the same Expectation several times for several callbacks.\nThe time here is important because it prevents your test from ever ending. This way we expect the task to last only a few seconds before it has to stop. In case the expectation stops because of the timeout your test will fail.\nI hope you enjoyed this article, don\u0026rsquo;t hesitate to share it or comment it. See you soon for more articles on mobility.\n","date":"31 May 2021","permalink":"/posts/swift-async-unit-test/","section":"Posts","summary":"In software development there is one thing that is difficult to achieve : quality.","title":"Swift : Async unit tests"},{"content":" Kotlin Cache Management # In computer science, we always say that there are two things that are complicated: naming variables and managing the cache! And that\u0026rsquo;s absolutely true. Unfortunately, this is a recurring problem in mobility since we must save as much as possible the network consumption of the mobile device we have in our hands:\n network loss weak networks (Edge, 3G,\u0026hellip;) \u0026hellip;  It is therefore important to know how to manage data caching in order to provide a meaningful user experience. But again, it will depend on the data:\nIf you manage more or less static data, such as the product catalogue of a major car brand, there is no need to refresh the data from the server every 10 seconds or at each user\u0026rsquo;s request. We can afford to load them only once and keep them as long as the application is alive the data loaded upstream.\nOf course there are also cases where, as in a purchasing application, some data must constantly be reloaded and the cache is not very efficient.\nSo first, we will focus on our first case and see how it is possible to set up a cache on a REST request in Kotlin.\nFirst of all, some dependencies need to be resolved. To develop this small demo application, we will need:\n androidx.appcompat:appcompat:1.0.2 androidx.core:core-ktx:1.0.2 androidx.constraintlayout:constraintlayout:1.1.3 com.squareup.retrofit2:retrofit:2.5.0 com.squareup.retrofit2:converter-gson:2.5.0 com.squareup.retrofit2:adapter-rxjava:2.5.0 com.squareup.okhttp3:logging-interceptor:3.12.1 io.reactivex.rxjava2:rxandroid:2.1.1 io.reactivex.rxjava2:rxkotlin:2.3.0 com.squareup.retrofit2:adapter-rxjava2:2.4.0 com.squareup.picasso:picasso:2.71828 androidx.legacy:legacy-support-v4:1.0.0 androidx.recyclerview:recyclerview:1.0.0 android.arch.lifecycle:extensions:1.1.1 androidx.cardview:cardview:1.0.0 jp.wasabeef:picasso-transformations:2.2.1 jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1 com.google.android.material:material:1.0.0  Don\u0026rsquo;t forget to synchronize your project via gradle after adding these dependencies. For this demo, we will use Rick and Morty\u0026rsquo;s free and open API : https://rickandmortyapi.com/\nFirst, we will display in a list the characters of Rick and Morty but without managing the pagination. The goal being to obtain something similar to this:\nNothing complicated so far. I won\u0026rsquo;t detail how to get to that but only on how to manage the cache. If the rest interests you, do not hesitate to consult the Git of this article.\nTo handle all this we\u0026rsquo;re going to need one of an ApiManager managing requests to the API:\nprivate const val API_BASE_URL = \u0026#34;https://rickandmortyapi.com/\u0026#34; class ApiManager { private val service: ApiService interface ApiService { @GET(\u0026#34;api/character\u0026#34;) fun retrieveCharacters(): Single\u0026lt;CharacterResult\u0026gt; @GET(\u0026#34;/api/character/{charactId}\u0026#34;) fun retrieveDetailCharactere(@Path(\u0026#34;charactId\u0026#34;) url: String): Single\u0026lt;Character\u0026gt; } init { service = Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client( OkHttpClient().newBuilder().addInterceptor(HttpLoggingInterceptor().apply { HttpLoggingInterceptor.Level.BASIC }) .build() ).build() .create(ApiService::class.java) } fun retrieveCharacters() = service.retrieveCharacters() fun retrieveDetailCharacter(url: String) = service.retrieveDetailCharactere(url) } As you can see, we will use Retrofit (lien YYYY) to manage API calls with an Rx adapter to manage observables.\nNevertheless, all intelligence will pass through the repository: CharactersRepository and CharactersCacheRepository. You have understood it one is for API calls as for the other, it takes care of loading the data from the cache i.e. RAM in our case.\nWe will therefore need an interface to transparently manage the two repositories :\ninterface ICharacterRepository { fun getCharacters(): Single\u0026lt;CharacterResult\u0026gt; fun getCharacterById(id: Long): Single\u0026lt;Character\u0026gt; } So we can now create our two classes:\nclass CharacterRepository(private val apiManager: ApiManager): ICharacterRepository { } class CharacterCacheRepository( private val delegate: CharacterRepository, private val characterResCache: ICharacterResultCache ): ICharacterRepository by delegate { } You will notice the presence of a new ICharacterCacheResult interface. But we\u0026rsquo;ll talk about it later.\nAs you can see, the principle is the same: We implement the interface. However, there will be 2 big changes:\nThe repository managing the cache has no direct link with the ApiManager and we use the keyword \u0026ldquo;delegate\u0026rdquo; for it. But what does this mean?\nAccording to the documentation available on Kotlang:\n The Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. A class Derived can implement an interface Base by delegating all of its public members to a specified object\n The goal is to have a repository that uses another one and not to have 2 repositories with logic everywhere in our code.\nSince each repository manages a particular data, it is possible to define different cache rules depending on the said data as we have seen previously!\nBut since both repositories use the same interface, it\u0026rsquo;s totally transparent for the rest of our code! In this case it is the repository managing the cache that will always be used. So we reverse the logic: rather than knowing if we are using the cache. By default we use this one and worry about when to use the network. It is therefore up to him to know whether or not to use the network depending on the cache he has and the management rules we want to put in place.\nLet\u0026rsquo;s now place directly in the application the instance of our CharacterCacheRepository which will take care of everything:\nlateinit var characterRepository: ICharacterRepository override fun onCreate() { super.onCreate() app = this initInjection() } private fun initInjection() { characterRepository = CharacterCacheRepository( CharacterRepository(ApiManager()), CharacterResultCache() ) } Don\u0026rsquo;t forget to link your android application to this class.\n\u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:roundIcon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/AppTheme\u0026#34; android:name=\u0026#34;.presentation.RMApplication\u0026#34;\u0026gt; ... \u0026lt;/application\u0026gt; It\u0026rsquo;s time to implement our repository and we\u0026rsquo;ll start with the simplest and the one we all know CharacterRepository:\nclass CharacterRepository(private val apiManager: ApiManager): ICharacterRepository { override fun getCharacters(): Single\u0026lt;CharacterResult\u0026gt; = apiManager.retrieveCharacters() override fun getCharacterById(id: Long): Single\u0026lt;Character\u0026gt; = apiManager.retrieveDetailCharacter(\u0026#34;$id\u0026#34;) } Nothing complicated here, we just use our ApiManager to do the job. No transformation required in this case.\nDo you remember the ICharacterCacheResult interface? It\u0026rsquo;s time to take care of it. In fact we will implement a class with this interface and it is it that will handle the management of cached data.\nclass CharacterResultCache: ICharacterResultCache { var mResult: CharacterResult? = null override val hasCharacters: Boolean get() = mResult != null override fun getResult(): CharacterResult? { return mResult } override fun getCharacter(id: Long): Maybe\u0026lt;Character\u0026gt; { mResult?.let { val found = it.results.filter { if (it.id == id) { return Maybe.just(it) } return Maybe.empty() }.first() return Maybe.just(found) } return Maybe.empty() } override fun getCharacters(): List\u0026lt;Character\u0026gt; { mResult?.let { return it.results } return emptyList() } override fun setResult(res: CharacterResult) { mResult = res } } We simply need to retrieve the list of characters or a particular character. To do this, simply analyze the result and save the result of the Http query.\nNow let\u0026rsquo;s do the simple version of our cache: If I have cache I send it back otherwise I make a request, I store the result and I return the result. As a result, at the next request there will be cache and there will be no need to make a new request to the server.\nclass CharacterCacheRepository( private val delegate: CharacterRepository, private val characterResCache: ICharacterResultCache ): ICharacterRepository by delegate { override fun getCharacters(): Single\u0026lt;CharacterResult\u0026gt; { if (characterResCache.hasCharacters) { return Single.create { emitter -\u0026gt; characterResCache.getResult()?.let { emitter.onSuccess(it) } } } else { return delegate.getCharacters().doOnSuccess { characters -\u0026gt; characterResCache.setResult(characters) } } } override fun getCharacterById(id: Long): Single\u0026lt;Character\u0026gt; { return characterResCache.getCharacter(id) .switchIfEmpty(delegate.getCharacterById(id)) } } All we have to do now is implement the apple in the repository in the viewModel of our page:\nclass CharactersViewModel : BaseViewModel() { var mItems: MutableLiveData\u0026lt;MutableList\u0026lt;Character\u0026gt;\u0026gt; = MutableLiveData() private var onSubscribe: Disposable? = null @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun onResume() { loadData() } override fun onCleared() { onSubscribe?.dispose() super.onCleared() } fun loadData() { mIsLoading.value = true val characterResult: Single\u0026lt;CharacterResult\u0026gt; = RMApplication.app.characterRepository.getCharacters() onSubscribe = characterResult .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribeBy( onSuccess = { mIsLoading.postValue(false) mItems.postValue(it.results.toMutableList()) }, onError = { mError.postValue(it) } ) } } There you go! You have a cache, some simple, but fully functional! Now it\u0026rsquo;s up to you to add new conditions to manage the cache of your application.\nIf you want to see the full code of this application, feel free to visit my git.\nIf you wish to discuss the subject, do not hesitate to contact me with a comment ;)\n","date":"19 April 2021","permalink":"/posts/kotlin-cache-management/","section":"Posts","summary":"Kotlin Cache Management # In computer science, we always say that there are two things that are complicated: naming variables and managing the cache!","title":"Kotlin: Cache Managment"},{"content":" Firebase is a very complete service offered by Google that allows a large number of things:\n Authentication Database Storage Hosting Functions ML Kit Crashlytics Performance Test Lab \u0026hellip;  And many other things!\nThe part we are interested in today is the cloud function.\nAs you probably know, cloud functions are simple pieces of code executed on demand. They are generally serveless and can therefore be executed anywhere and at any time without being repeated in a specific context.\nTherefore we will need triggers that will allow us to trigger the execution of a function. There are very simple triggers such as an HTTP call or database update.\nBut firebase also offers other types of triggers that can be used such as :\n Cloud Firestore Triggers Realtime Database Triggers Remote Config Triggers Google Analytics for Firebase Triggers Crashlytics Triggers Cloud Storage Triggers Cloud Pub/Sub Triggers HTTP Triggers  So we can imagine a whole bunch of scenarios like sending an email / an automatic notification to a user when he sends us a crashlytics report due to a bug in our application, it increases the quality of our application and the user experience but it costs us almost nothing as a developer.\nAs a mobile developer and iot I often need an API for my applications. The most common case is user administration for a website. We want to be able to:\n list users creates a new user disable a user activate a user  It should be noted that cloud functions run NodeJS, so we can use any library we want to create our API. Express being my favorite is what we\u0026rsquo;re going to use now.\nFirst of all we need to create our Firebase Function project. To do this, place yourself in a blank folder and execute the following command:\nIf you do not have to install the firebase tools, execute this command:\nfirebase init You should see the following choices in front of you:\nnpm install -g firebase-tools You should see the following choices in front of you:\nThen select your project.\nThe firebase tools will now create a complete cloud function project ready to be deployed for you. An index.js file will be created. This is the file that will be executed on the firebase platform. You can create other files but they must always be used in the index.js file.\nLike any NodeJS project, we will have a package.json file containing all our dependencies and a node_modules folder that will contain all the downloaded dependencies. So don\u0026rsquo;t forget to execute the command to install the packets:\nnpm i Let\u0026rsquo;s start by installing express and setting up the exit of a first road:\nnpm i express --save Let\u0026rsquo;s put the following code in the index.js file :\nconst functions = require(\u0026#39;firebase-functions\u0026#39;); const admin = require(\u0026#39;firebase-admin\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const app = express(); admin.initializeApp(); The libraries \u0026ldquo;firebase-functions\u0026rdquo; and \u0026ldquo;firebase-admin\u0026rdquo; will be necessary for the proper functioning of our API.\nLet\u0026rsquo;s create the first endpoint to test our function:\napp.get(\u0026#39;/test\u0026#39;, (req, res) =\u0026gt; { res.status(200).send(\u0026#39;It works!\u0026#39;) }); Nothing complicated, just sent us back text from the moment we call the route /test.\nWe no longer have any cases left where our express app is linked to an endpoint cloud function. To do this, simply enter this code:\nexports.admin = functions.https.onRequest(app); admin is the name of our cloud function.\nTo test in real conditions, we will have to deploy our cloud function. To do this, we just need to execute the following command:\nfirebase deploy You should now see this in the Dashboard tab:\nIn this picture, the part in red is the address where you can call your cloud function. Don\u0026rsquo;t forget to add /test in our case for this to work.\nUse software such as postman to make our request and test. Everything should work perfectly. If not, go to the \u0026ldquo;Logs\u0026rdquo; tab of the firebase to better understand what happened.\nUser API # As we said earlier, we want to list users, enable/disable them and be able to create new ones.\nLet\u0026rsquo;s start by creating a new user:\nAs required by the convention, for a creation we use the POST method.\napp.post(\u0026#39;/createAdmin\u0026#39;, async (req, res) =\u0026gt; { try { const userInDto = dto.createUserInDto(req); await admin.auth().createUser({ email: userInDto.email, emailVerified: false, password: userInDto.password, displayName: userInDto.username, disabled: false }); res.status(201).send(\u0026#39;\u0026#39;); } catch (ex) { console.log(\u0026#39;error\u0026#39;, ex); res.status(400).send( dto.createErrorOutDto( 100, \u0026#39;Something goes wrong!\u0026#39; ) ); } }); In order to be a little cleaner, I created a dto.js file that contains some very useful methods to convert incoming data to model and vice versa.\nfunction createUserInDto(req) { if (req.method !== \u0026#39;POST\u0026#39;) { console.log(\u0026#39;request method is not POST\u0026#39;, req); throw new Error(\u0026#39;Not POST methods\u0026#39;); } const val = req.body; if (!(\u0026#39;username\u0026#39; in val) || !(\u0026#39;password\u0026#39; in val) || !(\u0026#39;email\u0026#39; in val)) { console.log(\u0026#39;some data isnt ok\u0026#39;, val); throw new Error(\u0026#39;Malformed JSON Body\u0026#39;); } return { username: val.username, password: val.password, email: val.email } } function createErrorOutDto(code, ex) { return { errorCode: code, errorMessage: ex } } function createFirebaseUserOutDto(json) { return { id: json.uid, email: json.email, username: json.displayName !== undefined ? json.displayName : \u0026#39;\u0026#39;, disabled: json.disabled, } } module.exports = { createUserInDto: createUserInDto, createErrorOutDto: createErrorOutDto, createFirebaseUserOutDto: createFirebaseUserOutDto } As you can see nothing complicated here, we retrieve the data from the request and use the createUser method of the firebase-admin library to create a new user.\nAs for the activation or deactivation, nothing more complicated:\napp.put(\u0026#39;/user/enable/:id\u0026#39;, async (req, res) =\u0026gt; { changeUser(req, res, true); }); app.put(\u0026#39;/user/disable/:id\u0026#39;, async (req, res) =\u0026gt; { changeUser(req, res, false); }); async function changeUser(req, res, enable) { try { const userId = req.params.id; if (userId === undefined || userId === null) { throw new Error(\u0026#39;userId is not set\u0026#39;); } await admin.auth().updateUser(userId, { disabled: !enable }); res.status(200).send(\u0026#39;\u0026#39;); } catch (ex) { res.status(400).send( dto.createErrorOutDto( 100, \u0026#39;Something goes wrong!\u0026#39; ) ); } } All we have to do now is list all the users of the database.\napp.get(\u0026#39;/users\u0026#39;, async (req, res) =\u0026gt; { try { const users = await admin.auth().listUsers(); let result = []; users.users.forEach((userRecord) =\u0026gt; { const newUser = dto.createFirebaseUserOutDto(userRecord.toJSON()); result.push(newUser); }); res.status(200).send(result); } catch (ex) { res.status(400).send( dto.createErrorOutDto( 100, \u0026#39;Something goes wrong!\u0026#39; ) ); } }); Securing the API # We were able to make all the requests we wanted and quite easily. Now it is a question of securing our API in order to prevent anyone from calling it directly without our permission. To do this we will simply add an API key.\nFor that we will add a verification middleware. It will have to be placed before our requests if we want it to take effect:\nconst apiKeyMiddleware = (req, res, next) =\u0026gt; { const apiKeyHeader = req.headers.apikey; if (apiKeyHeader === config.apiKey) { next(); return; } else { res.status(401).send(\u0026#39;\u0026#39;); } }; Replace the config.apiKey by the key you want to use.Then call the middleware:\napp.use(apiKeyMiddleware); You no longer have to call the API with our key in the headers. And here is your API for firebase users is ready.\n","date":"18 April 2021","permalink":"/posts/firebase-functions/","section":"Posts","summary":"Firebase is a very complete service offered by Google that allows a large number of things:","title":"Firebase : Functions"},{"content":" Firebase # As I have already mentioned in this article, Firebase is a service offered by Google for mobile and web developers to facilitate a large number of parts of application development:\n Authentication NoSql Database cloud function Storage (image, video, \u0026hellip;) Web application hosting Real-time database Test lab Crash reporting in real time Remote config Cloud messaging  It is therefore a very useful service for the rapid prototyping of an application and even for an application in production and all this for a very modest price.\nAzure DevOps # Azure DevOps is a service offered by Microsoft and the direct descendant of VSTS and Team Foundation. It is an online service that allows you to manage a number of things:\n Backlog management (scrum, agile,\u0026hellip;) Git directory management Test Plan Management Artifacts management Pipeline management  All the tools necessary to manage a development team, both from the point of view of the Product Owner and the developer.\nCloud function # Definition # Have you already done cloud functions? If you do not know this is a code that is triggered according to an event and starts processing. The most frequently encountered cases are:\n Sending an email when creating a user Receiving an http request Modifying a field in a database  The principle of a cloud function is that it is called \u0026ldquo;serverless\u0026rdquo;. Therefore, there is no need to take care of the server that is located and no need to manage the load, since it is possible to create as many as one trigger triggered.\nMany offers exist on the net to create and host cloud function:\n Microsoft with Azure Functions Google with GCP Cloud Function Google with Firebase Function IBM with IBM Cloud Function Parse with Cloud Code Amazon with AWS Lambda Red Hat with OpenShift Cloud Function  We therefore encounter more and more of them and it becomes important to know this type of service.\nSample # To practice a little, we will create a very simple code for the Firebase cloud function. This function will be placed on an HTTP request.\n\u0026#39;use strict\u0026#39;; const functions = require(\u0026#39;firebase-functions\u0026#39;); const moment = require(\u0026#39;moment\u0026#39;); const cors = require(\u0026#39;cors\u0026#39;)({ origin: true, }); exports.date = functions.https.onRequest((req, res) =\u0026gt; { return cors(req, res, () =\u0026gt; { let format = req.query.format; if (!format) { format = req.body.format; } const formattedDate = moment().format(format); console.log(\u0026#39;Sending Formatted date:\u0026#39;, formattedDate); res.status(200).send(formattedDate); }); }); The purpose of this code, as simple as it may be, is to return the server date according to the format sent (via the request or the body). If you have never done a Firebase cloud function before, that here \u0026ldquo;exports.date\u0026rdquo; allows you to expose the cloud function which will be named \u0026ldquo;date\u0026rdquo; and will be present in the url of it.\nIf you want to have a large number of examples, I invite you to visit Google\u0026rsquo;s GitHub for Firebase: https://github.com/firebase/functions-samples\nPractice # Let\u0026rsquo;s start by creating a new pipeline. For simplicity\u0026rsquo;s sake, I advise you to host your git directly on DevOps. Select Azure Repos Git. If not, choose the provider that suits you.\nOnce you have selected your git, you will be able to select the basic configuration. This is a simple tool that will pre-construct a yaml script containing a set of pre-defined tasks for the chosen project type. Of course, everything can be modified at will.\nIn our case, we will select Node.js as you can see below.\nThe following script will have been generated. It is interesting but does not yet allow us to deploy on firebase. To do this, we will have to make some changes.\n# Node.js# Build a general Node.js project with npm.# Add steps that analyze code, save build artifacts, deploy, and more:# https://docs.microsoft.com/azure/devops/pipelines/languages/javascripttrigger:- masterpool:vmImage:\u0026#39;ubuntu-latest\u0026#39;steps:- task:NodeTool@0inputs:versionSpec:\u0026#39;10.x\u0026#39;displayName:\u0026#39;Install Node.js\u0026#39;- script:|npm install npm run builddisplayName:\u0026#39;npm install and build\u0026#39;The main gap is the set of Firebase commands and in particular firebase deploy:\n# Node.js# Build a general Node.js project with npm.# Add steps that analyze code, save build artifacts, deploy, and more:# https://docs.microsoft.com/azure/devops/pipelines/languages/javascripttrigger:- master- developpool:vmImage:\u0026#39;ubuntu-latest\u0026#39;steps:- task:NodeTool@0inputs:versionSpec:\u0026#39;10.x\u0026#39;displayName:\u0026#39;Install Node.js\u0026#39;- script:|cd functions npm install -g firebase-tools npm install firebase deploy --token $(firebase-token) --project $(firebase-project) --only functions --forcedisplayName:\u0026#39;npm install and deploy\u0026#39;As you can see in lines 7 and 8, this pipeline is triggered on a commit (merge in theory: you don\u0026rsquo;t directly commit to master or develop by pity! ðŸ˜¤) of master as well as develop. It is up to you to change these values if you want a different behaviour.\nAs the execution of commands is not related to the OS we are on (vive nodeJs and its cross compatibility), we will use ubuntu.\nAs I said earlier, we will need NodeJs to work. This installation will also add NPM. In the current script I ask for a version 10 of NodeJS, if you are compatible with newer versions, you can quite let it choose \u0026lsquo;latest\u0026rsquo;.\nOnce NodeJS is installed, there is no magic, you will have to execute exactly the same commands as on your development machine. To do this we need the Firebase tools. Here again nothing new, we use the command npm install -g firebase-tools to add them.\nWe then update our node_modules with the command npm i or npm install.\nIn this case I use JS directly, so there is no need to transpose anything (e. g. typescript) but it is quite possible for you to do so too. Remember that you are on a \u0026ldquo;classic\u0026rdquo; machine and can therefore add tools.\nWe can therefore proceed directly to deployment on Firebase. But here a small problem arises: my credentials.\nIn theory on your development machine no problem, you enter your credentials on the fly and they are safe in your head (or worse on a Post-It ðŸ˜¡). But leave them lying around on a build machine that doesn\u0026rsquo;t belong to you\u0026hellip; well, I don\u0026rsquo;t recommend it! Even if Microsoft does not use them, it is a very bad practice. Therefore, we will use the \u0026ldquo;Variables\u0026rdquo; tab provided for the DevOps tool.\nTo do this, click on the \u0026ldquo;Variables\u0026rdquo; button just above the editing area of the pipeline script:\nYou will see the following popup displayed:\nAs you can see, I have personally already entered two hidden variables: firebase-project and firebase token.\nYou will find them in particular in line 23 of the pipeline script. They are the ones that allow for safe deployment. This way, if another member of your team has access to your pipeline but you do not want them to see/use your credentials, it is now possible.\nIt is now possible for you to automatically deploy your code on Firebase ! Isn\u0026rsquo;t that wonderful? If you wish to test it, simply click on the \u0026ldquo;Run\u0026rdquo; button located at the same level as the \u0026ldquo;Variable\u0026rdquo; button or save and commit to the trigger branch(s) of this pipeline.\nDon\u0026rsquo;t forget that Azure DevOps offers you 1800 minutes per month of shared pipeline. Something to start having fun and even work with ðŸ˜.\n","date":"18 April 2021","permalink":"/posts/firebase-azure-devops/","section":"Posts","summary":"Firebase # As I have already mentioned in this article, Firebase is a service offered by Google for mobile and web developers to facilitate a large number of parts of application development:","title":"Firebase and Azure DevOps"},{"content":" Upload flutter projet on Google Play # Have you ever tried flutter? If not, I invite you to do it, it\u0026rsquo;s worth a visit!\nBut did you go as far as publishing on stores and especially on Google Play?\nI personally tried to publish an application made with this technology on Google Play but I found myself faced with an unexpected error:\nThat\u0026rsquo;s a problem!\nFortunately Android Studio allows us to compile for several platforms in the same APK but also to compile several APK, each for a different platform!\nFirst of all, add the following code to your \u0026ldquo;app/build.gradle\u0026rdquo; file:\nsplits { abi { enable true reset() include \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;arm64-v8a\u0026#34; universalApk false } } From there, at each compilation you will generate several APKs. One per platform, here armeabi-v7a and arm64-v8a.\nNow you can start compiling for both platforms.\nflutter build apk --release --target-platform=android-arm An APK with the name app-armeabi-v7a-release.apk will be generated. Note that the 2 APKs will be generated each time but it is important to use only the one mentioned above.\nNow increment the CodeVersion property of your project otherwise Google Play will refuse your new APK:\nYou can now generate the second APK with the command:\nflutter build apk --release --target-platform=android-arm64 The new APK will be appointed app-arm64-v8a-release.apk.\nThe Google Play console should accept this second APK without any problem. Repeat the check and everything should work fine!\nAlso remember that it is essential to prepare for the future with the new APK x64.\nSo since this is a Google technology, we can imagine that a solution will be considered very soon!\nI hope this article will get you more! Feel free to contact me to discuss further ;)\n","date":"18 April 2021","permalink":"/posts/upload-flutter-googleplay/","section":"Posts","summary":"Upload flutter projet on Google Play # Have you ever tried flutter?","title":"Upload flutter project on Google Play"}]